name: Build Clients

on:
  push:
    branches: [master]
    paths:
      - "scripts/**"
      - "sail_ui/**"
      - "bitwindow/**"
      - "thunder/**"
      - "bitnames/**"
      - "bitassets/**"
      - "zside/**"
      - ".github/workflows/**"
  pull_request:
    branches: [master]
    paths:
      - "scripts/**"
      - "sail_ui/**"
      - "bitwindow/**"
      - "thunder/**"
      - "bitnames/**"
      - "bitassets/**"
      - "zside/**"
      - ".github/workflows/**"

jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      thunder: ${{ steps.filter.outputs.thunder }}
      bitnames: ${{ steps.filter.outputs.bitnames }}
      bitassets: ${{ steps.filter.outputs.bitassets }}
      zside: ${{ steps.filter.outputs.zside }}
      bitwindow: ${{ steps.filter.outputs.bitwindow }}
      build_all: ${{ steps.filter.outputs.build_all }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            thunder:
              - 'scripts/**'
              - 'thunder/**'
              - 'sail_ui/**'
              - '.github/workflows/**'
            bitnames:
              - 'scripts/**'
              - 'bitnames/**'
              - 'sail_ui/**'
              - '.github/workflows/**'
            bitassets:
              - 'scripts/**'
              - 'bitassets/**'
              - 'sail_ui/**'
              - '.github/workflows/**'
            zside:
              - 'scripts/**'
              - 'zside/**'
              - 'sail_ui/**'
              - '.github/workflows/**'
            bitwindow:
              - 'scripts/**'
              - 'bitwindow/**'
              - 'sail_ui/**'
              - '.github/workflows/**'

  matrix-prep:
    needs: check-changes
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - id: set-matrix
        run: |
          # Start with empty array
          configurations=()

          # Helper function to add configurations
          add_client_configs() {
            local client=$1
            local build_flag=$2
            
            if [[ "${{ needs.check-changes.outputs.build_all }}" == "true" || "$build_flag" == "true" ]]; then
              for os in "ubuntu-latest" "macos-latest" "windows-latest"; do
                # Skip macOS and linux for PRs
                if [[ "${{ github.event_name }}" == "pull_request" && "$os" == "ubuntu-latest" ]]; then
                  continue
                fi
                
                # Skip Windows for zside
                if [[ "$client" == "zside" && "$os" == "windows-latest" ]]; then
                  continue
                fi
                
                # No chains - just add the basic config
                configurations+=("{\"os\":\"$os\",\"client\":\"$client\"}")
              done
            fi
          }

          # Add configurations for each client that needs building
          add_client_configs "thunder" "${{ needs.check-changes.outputs.thunder }}"
          add_client_configs "bitnames" "${{ needs.check-changes.outputs.bitnames }}"
          add_client_configs "bitassets" "${{ needs.check-changes.outputs.bitassets }}"
          add_client_configs "zside" "${{ needs.check-changes.outputs.zside }}"
          add_client_configs "bitwindow" "${{ needs.check-changes.outputs.bitwindow }}"

          # Join configurations with commas
          matrix=$(IFS=,; echo "{\"include\":[${configurations[*]}]}")
          echo "matrix=$matrix" >> $GITHUB_OUTPUT

  build:
    needs: matrix-prep
    runs-on: ${{ matrix.os }}
    defaults:
      run:
        shell: bash
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix-prep.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v4

      - uses: subosito/flutter-action@v2
        with:
          channel: stable
          flutter-version: 3.35.2

      - name: Install Fastforge - a tool for building and distributing apps
        run: dart pub global activate fastforge

      - uses: extractions/setup-just@v1
      # Setup go for building bitwindowd
      - uses: actions/setup-go@v5
        with:
          go-version: "1.25"

      - name: Setup build directory
        run: |
          # Create build directory name, to avoid caching assets/bin across OSes
          BUILD_DIR="b-${{ matrix.os }}"
          rm -rf "$BUILD_DIR"
          mkdir -p "$BUILD_DIR"
          # Copy source files to build directory
          cp -r ${{ matrix.client }} "$BUILD_DIR/"
          cp -r scripts "$BUILD_DIR/"
          cp -r sail_ui "$BUILD_DIR/"
          # Recreate assets/bin directory
          mkdir -p "$BUILD_DIR/${{ matrix.client }}/assets/bin"
          echo "BUILD_DIR=$BUILD_DIR" >> $GITHUB_ENV

      - name: Install Flutter dependencies
        run: |
          cd ${{ env.BUILD_DIR }}/${{ matrix.client }}
          flutter pub get --enforce-lockfile

        # standard macOS sed has subtle differences from gnu
      - name: Install GNU sed on macOS
        if: runner.os == 'macOS'
        run: |
          brew install gnu-sed
          echo "$(brew --prefix)/opt/gnu-sed/libexec/gnubin" >> $GITHUB_PATH

        # https://docs.flutter.dev/get-started/install/linux/desktop
      # prettier-ignore
      - run:  sudo apt-get update -y && sudo apt-get upgrade -y && sudo apt-get install -y curl git unzip xz-utils zip libglu1-mesa && sudo apt-get install clang cmake git ninja-build pkg-config libgtk-3-dev liblzma-dev libstdc++-12-dev libcurl4-openssl-dev
        if: runner.os == 'Linux'

      # Install FUSE and other dependencies for AppImage creation
      - name: Install FUSE and AppImage dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get install -y fuse libfuse2 squashfs-tools
          # Enable FUSE for non-root users
          sudo modprobe fuse || echo "FUSE module already loaded or not available"
          sudo chmod 666 /dev/fuse || echo "FUSE device not available"

      # Install appimagetool for AppImage creation on Linux
      - name: Install appimagetool
        if: runner.os == 'Linux'
        run: |
          wget https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
          chmod +x appimagetool-x86_64.AppImage
          sudo mv appimagetool-x86_64.AppImage /usr/local/bin/appimagetool

      # Install snapcraft and LXD for snap package building
      - name: Install snapcraft
        if: runner.os == 'Linux' && matrix.client == 'bitwindow'
        run: |
          # Install LXD
          sudo snap install lxd

          # Add runner to lxd group
          sudo groupadd --force --system lxd
          sudo usermod --append --groups lxd runner

          # Initialize LXD
          sudo lxd init --auto

          # Fix potential Docker interference with LXD networking
          sudo iptables -P FORWARD ACCEPT

          # Install snapcraft
          sudo snap install snapcraft --channel=7.x/stable --classic

          # Test LXD connection
          newgrp lxd << 'EOF'
          lxc list
          EOF

      - name: Setup macOS app signing
        if: runner.os == 'macOS'
        run: |
          # import certificate into the keychain
          echo "${{ secrets.MACOS_CERTIFICATE }}" | base64 --decode > certificate.p12
          KEYCHAIN_PASSWORD=$(uuidgen)

          echo "Creating keychain"
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain

          echo "Setting default keychain"
          security default-keychain -s build.keychain

          echo "Unlocking keychain"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain

          echo "Setting keychain timeout to 20 minutes"
          security set-keychain-settings -t 1200 -l ~/Library/Keychains/build.keychain

          echo "Importing certificate into keychain"
          security import ./certificate.p12 -k ~/Library/Keychains/build.keychain -P ${{ secrets.MACOS_CERTIFICATE_PASSWORD }} -T /usr/bin/codesign

          echo "Setting key partition list"
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" ~/Library/Keychains/build.keychain

          # Find the Common Name of the certificate we just imported
          security find-certificate -a -p build.keychain > certificate.pem
          cert_subject=$(openssl x509 -in certificate.pem -noout -subject)
          echo Certificate subject: "'$cert_subject'"

          cn_part=$(grep -o 'CN = "[^"]*"' <<< "$cert_subject")
          cn_value=$(sed 's/CN = "\(.*\)"/\1/' <<< "$cn_part")
          echo "Determined code sign identity"

          # Create notarization API key file in the build directory
          echo "Creating notarization API key file in ${{ env.BUILD_DIR }}"
          echo ${{ secrets.GODOT_MACOS_NOTARIZATION_API_KEY }} | base64 --decode > "${{ env.BUILD_DIR }}/notarization_api_key.p8"

          # Set the standardized environment variables
          echo "NOTARIZATION_KEY_PATH=$PWD/${{ env.BUILD_DIR }}/notarization_api_key.p8" >> $GITHUB_ENV
          echo "NOTARIZATION_KEY_PASSWORD=" >> $GITHUB_ENV  # Empty for API key auth
          echo "NOTARIZATION_IDENTITY=$cn_value" >> $GITHUB_ENV

      - name: Setup Windows code signing
        if: runner.os == 'Windows'
        run: |
          # Create windows-certificate file from base64 secret
          echo "${{ secrets.MICROSOFT_CODE_SIGNING_OV_KEY_PFX_BASE64 }}" | base64 --decode > "${{ env.BUILD_DIR }}/windows-certificate.pfx"

          # Convert PFX to PEM to extract subject
          openssl pkcs12 -in "${{ env.BUILD_DIR }}/windows-certificate.pfx" -out "${{ env.BUILD_DIR }}/windows-certificate.pem" -nodes -passin pass:"${{ secrets.MICROSOFT_CODE_SIGNING_OV_KEY_PFX_PASSWORD }}"

          # Extract the subject from the certificate
          cert_subject=$(openssl x509 -in "${{ env.BUILD_DIR }}/windows-certificate.pem" -noout -subject)
          echo "Certificate subject: '$cert_subject'"

          # Extract Common Name from subject - fix the grep pattern to handle CN= format
          cn_value=$(echo "$cert_subject" | grep -o 'CN=[^,]*' | sed 's/CN=//' | tr -d '"')

          echo "Extracted identity: '$cn_value'"

          # Set the standardized environment variables
          echo "NOTARIZATION_KEY_PATH=$PWD/${{ env.BUILD_DIR }}/windows-certificate.pfx" >> $GITHUB_ENV
          echo "NOTARIZATION_KEY_PASSWORD=${{ secrets.MICROSOFT_CODE_SIGNING_OV_KEY_PFX_PASSWORD }}" >> $GITHUB_ENV
          echo "NOTARIZATION_IDENTITY=$cn_value" >> $GITHUB_ENV

        shell: bash

      # Install Intel Homebrew into /usr/local using Rosetta
      - name: Install Intel Homebrew + dependencies
        if: runner.os == 'macOS' && matrix.client == 'bitwindow'
        run: |
          arch -x86_64 /bin/bash -lc \
            "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
          echo '/usr/local/bin' >> $GITHUB_PATH
          /usr/local/bin/brew install zeromq

      - name: Install ZMQ dependencies for Windows
        if: runner.os == 'Windows' && matrix.client == 'bitwindow'
        run: |
          git clone https://github.com/microsoft/vcpkg.git
          cd vcpkg
          ./bootstrap-vcpkg.bat
          ./vcpkg.exe install zeromq:x64-windows
          VCPKG_ROOT="$(pwd)"
          echo "CGO_CFLAGS=-I${VCPKG_ROOT}/installed/x64-windows/include" >> $GITHUB_ENV
          echo "CGO_LDFLAGS=-L${VCPKG_ROOT}/installed/x64-windows/lib -llibzmq-mt-4_3_5" >> $GITHUB_ENV
          echo "PKG_CONFIG_PATH=${VCPKG_ROOT}/installed/x64-windows/lib/pkgconfig" >> $GITHUB_ENV

      - name: Build app
        run: |
          set -e
          cd ${{ env.BUILD_DIR }}

          # For Linux bitwindow builds, move files to snap/local to avoid warnings
          if [[ "${{ runner.os }}" == "Linux" && "${{ matrix.client }}" == "bitwindow" ]]; then
            if [ -f "${{ matrix.client }}/snap/bitwindow.desktop" ] || [ -f "${{ matrix.client }}/snap/bitwindow.png" ]; then
              mkdir -p ${{ matrix.client }}/snap/local
              [ -f "${{ matrix.client }}/snap/bitwindow.desktop" ] && mv ${{ matrix.client }}/snap/bitwindow.desktop ${{ matrix.client }}/snap/local/
              [ -f "${{ matrix.client }}/snap/bitwindow.png" ] && mv ${{ matrix.client }}/snap/bitwindow.png ${{ matrix.client }}/snap/local/
            fi
          fi

          # Everything after the third line is only relevant for macOS
          ./scripts/build-app.sh ${{ runner.os }} ${{ matrix.client }} \
            "$NOTARIZATION_KEY_PATH" "$NOTARIZATION_KEY_PASSWORD" \
            "$NOTARIZATION_IDENTITY" \
            ${{ secrets.GODOT_MACOS_NOTARIZATION_API_KEY_ID }} \
            ${{ secrets.GODOT_MACOS_NOTARIZATION_API_UUID }}

      - name: Generate version.json for this build
        run: |
          ./scripts/generate-version.sh ${{ matrix.client }}

          # Find a .zip, .exe or .appimage in release directory
          built_file=$(find "${{ env.BUILD_DIR }}/${{ matrix.client }}/release/" -name "*.exe" -o -name "*.appimage" -o -name "*.zip" | head -1)
          if [ -n "$built_file" ]; then
            # Map GitHub runner OS to platform name
            case "${{ matrix.os }}" in
              ubuntu-latest) platform="linux" ;;
              macos-latest) platform="macos" ;;  
              windows-latest) platform="windows" ;;
              *) platform="${{ matrix.os }}" ;;
            esac
            
            # Get all version info from lib/gen/version.dart (must exist)
            if [ ! -f "${{ matrix.client }}/lib/gen/version.dart" ]; then
              echo "ERROR: ${{ matrix.client }}/lib/gen/version.dart does not exist!"
              exit 1
            fi
            
            version=$(grep 'const String version =' "${{ matrix.client }}/lib/gen/version.dart" | sed "s/.*= '\(.*\)';.*/\1/")
            commit_hash=$(grep 'const String commit =' "${{ matrix.client }}/lib/gen/version.dart" | sed "s/.*= '\(.*\)';.*/\1/")
            commit_full=$(grep 'const String commitFull' "${{ matrix.client }}/lib/gen/version.dart" | sed "s/.*= '\(.*\)';.*/\1/")
            build_date=$(grep 'const String buildDate' "${{ matrix.client }}/lib/gen/version.dart" | sed "s/.*= '\(.*\)';.*/\1/")
            
            # Get file size and download URL
            file_size=$(stat -c%s "$built_file" 2>/dev/null || stat -f%z "$built_file" 2>/dev/null || wc -c < "$built_file")
            
            download_url=$(basename "$built_file")
            
            # Create version.json
            printf '{\n  "%s": {\n    "%s": {\n      "version": "%s",\n      "commit": "%s",\n      "commitFull": "%s",\n      "buildDate": "%s",\n      "downloadUrl": "%s",\n      "size": %s\n    }\n  }\n}\n' \
              "${{ matrix.client }}" "$platform" "$version" "$commit_hash" "$commit_full" "$build_date" "$download_url" "$file_size" \
              > "${{ env.BUILD_DIR }}/${{ matrix.client }}/release/${{ matrix.client }}-${{ matrix.os }}-version.json"
            cat "${{ env.BUILD_DIR }}/${{ matrix.client }}/release/${{ matrix.client }}-${{ matrix.os }}-version.json"
          fi

          echo "Content of created file:"
          cat "${{ env.BUILD_DIR }}/${{ matrix.client }}/release/${{ matrix.client }}-${{ matrix.os }}-version.json"

      - name: Generate appcast fragment for this build
        continue-on-error: true
        run: |
          built_file=$(find "${{ env.BUILD_DIR }}/${{ matrix.client }}/release/" -name "*.exe" -o -name "*.zip" | head -1)
          if [ -n "$built_file" ]; then
            # Map GitHub runner OS to platform and generate appcast
            case "${{ matrix.os }}" in
              ubuntu-latest) 
                # Linux doesn't need appcast fragments (no auto-updater)
                echo "Skipping appcast fragment for Linux"
                exit 0
                ;;
              macos-latest)
                echo "Generating appcast fragment for macOS"
                # Create EdDSA key file for macOS
                echo "${{ secrets.SPARKLE_MACOS_PRIVATE_KEY }}" > sparkle_macos_key.pem
                chmod +x scripts/appcast/generate-macos.sh
                cd "${{ env.BUILD_DIR }}"
                ../scripts/appcast/generate-macos.sh ${{ matrix.client }} "../sparkle_macos_key.pem" "${{ matrix.client }}/release/$(basename "$built_file")" || echo "Failed to generate $platform appcast fragment"
                rm -f ../sparkle_macos_key.pem
                ;;  
              windows-latest)
                echo "Generating appcast fragment for Windows"
                # Create DSA key file for Windows
                echo "${{ secrets.SPARKLE_WINDOWS_PRIVATE_KEY }}" | base64 -d > sparkle_dsa_key.pem
                chmod +x scripts/appcast/generate-windows.sh
                cd "${{ env.BUILD_DIR }}"
                ../scripts/appcast/generate-windows.sh ${{ matrix.client }} "../sparkle_dsa_key.pem" "${{ matrix.client }}/release/$(basename "$built_file")" || echo "Failed to generate Windows appcast fragment"
                rm -f ../sparkle_dsa_key.pem
                ;;
              *) 
                echo "Unknown platform: ${{ matrix.os }}"
                exit 0
                ;;
            esac

            cd ..
            
            # Check if fragment was generated (for macOS and Windows only)
            case "${{ matrix.os }}" in
              macos-latest)
                fragment_file="${{ env.BUILD_DIR }}/${{ matrix.client }}/release/${{ matrix.client }}-macos-fragment.xml"
                ;;
              windows-latest)
                fragment_file="${{ env.BUILD_DIR }}/${{ matrix.client }}/release/${{ matrix.client }}-windows-fragment.xml"
                ;;
            esac
            
            if [ -n "${fragment_file:-}" ] && [ -f "$fragment_file" ]; then
              echo "Generated appcast fragment: $fragment_file"
              cat "$fragment_file"
            elif [ -n "${fragment_file:-}" ]; then
              echo "No appcast fragment was generated"
            fi
          fi

      # Publish snap (bitwindoww doesn't exist, so we never publish!)
      - name: Publish snap
        if:
          runner.os == 'Linux' && matrix.client == 'bitwindoww' &&
          github.event_name == 'push' && github.ref == 'refs/heads/master'
        run: |
          # Decode the base64 credentials and export to environment
          export SNAPCRAFT_STORE_CREDENTIALS=$(echo "${{ secrets.SNAPCRAFT_LOGIN }}" | base64 --decode)
          echo "=========================================="
          echo "SNAP PUBLISHING SCRIPT STARTED"
          echo "=========================================="
          echo "Time: $(date)"
          echo "Matrix client: ${{ matrix.client }}"
          echo "Build directory: ${{ env.BUILD_DIR }}"
          echo "GitHub ref: ${{ github.ref }}"
          echo "GitHub event: ${{ github.event_name }}"

          # Semantic version comparison function
          # Returns 0 if v1 > v2, 1 if v1 < v2, 2 if v1 == v2
          compare_versions() {
            local v1="$1"
            local v2="$2"
            
            echo "[DEBUG] Comparing versions: '$v1' vs '$v2'"
            
            # Store original versions for debugging
            local orig_v1="$v1"
            local orig_v2="$v2"
            
            # Remove 'v' prefix if present and any '+' suffix (like 0.0.4+1)
            v1="${v1#v}"
            v1="${v1%%+*}"
            v2="${v2#v}"
            v2="${v2%%+*}"
            
            echo "[DEBUG] After cleanup: '$v1' vs '$v2'"
            
            # Split versions into arrays
            IFS='.' read -ra V1_PARTS <<< "$v1"
            IFS='.' read -ra V2_PARTS <<< "$v2"
            
            echo "[DEBUG] V1 parts: ${V1_PARTS[@]}"
            echo "[DEBUG] V2 parts: ${V2_PARTS[@]}"
            
            # Pad arrays to same length with zeros
            local max_len=$((${#V1_PARTS[@]} > ${#V2_PARTS[@]} ? ${#V1_PARTS[@]} : ${#V2_PARTS[@]}))
            echo "[DEBUG] Max length for comparison: $max_len"
            
            for ((i=0; i<max_len; i++)); do
              local part1="${V1_PARTS[i]:-0}"
              local part2="${V2_PARTS[i]:-0}"
              
              echo "[DEBUG] Comparing part $i: $part1 vs $part2"
              
              # Compare numerically
              if ((part1 > part2)); then
                echo "[DEBUG] Part $part1 > $part2, returning v1 > v2"
                return 0  # v1 > v2
              elif ((part1 < part2)); then
                echo "[DEBUG] Part $part1 < $part2, returning v1 < v2"
                return 1  # v1 < v2
              fi
            done
            
            echo "[DEBUG] All parts equal, returning v1 == v2"
            return 2  # versions are equal
          }

          echo ""
          echo "==== STEP 1: Getting version from pubspec.yaml ===="
          echo "Looking in: ${{ env.BUILD_DIR }}/${{ matrix.client }}/pubspec.yaml"

          if [ ! -f "${{ env.BUILD_DIR }}/${{ matrix.client }}/pubspec.yaml" ]; then
            echo "ERROR: pubspec.yaml not found at expected location!"
            ls -la "${{ env.BUILD_DIR }}/${{ matrix.client }}/" || echo "Directory doesn't exist"
            exit 1
          fi

          echo "pubspec.yaml contents (first 20 lines):"
          head -20 "${{ env.BUILD_DIR }}/${{ matrix.client }}/pubspec.yaml"

          # Get version from pubspec.yaml (handles version+build format)
          RAW_VERSION=$(grep '^version: ' "${{ env.BUILD_DIR }}/${{ matrix.client }}/pubspec.yaml")
          echo "[DEBUG] Raw grep output: '$RAW_VERSION'"

          NEW_VERSION=$(echo "$RAW_VERSION" | sed 's/version: //' | tr -d ' ')
          echo "[DEBUG] Extracted version: '$NEW_VERSION'"

          # Validate version format
          echo ""
          echo "==== STEP 2: Validating version format ===="
          if ! echo "$NEW_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(\+[0-9]+)?$'; then
            echo "ERROR: Invalid version format in pubspec.yaml: '$NEW_VERSION'"
            echo "Expected format: X.Y.Z or X.Y.Z+BUILD"
            echo "Regex pattern: ^[0-9]+\.[0-9]+\.[0-9]+(\+[0-9]+)?$"
            exit 1
          fi
          echo "✓ Version format is valid: $NEW_VERSION"

          # Try multiple methods to get current snap version from store
          echo ""
          echo "==== STEP 3: Getting current snap version from store ===="
          CURRENT_VERSION=""
          SNAP_NAME="${{ matrix.client }}"

          echo "Snap name: $SNAP_NAME"
          echo "Checking for snapcraft command..."
          which snapcraft || echo "WARNING: snapcraft not found in PATH"
          echo "Snapcraft version:"
          snapcraft version || echo "Could not get snapcraft version"

          # Method 1: Use snapcraft list-revisions (most reliable)
          echo ""
          echo "---- Method 1: snapcraft list-revisions ----"
          if command -v snapcraft >/dev/null 2>&1; then
            echo "Executing: snapcraft list-revisions \"$SNAP_NAME\""
            # Get the latest revision from edge channel
            REVISION_OUTPUT=$(snapcraft list-revisions "$SNAP_NAME" 2>&1 || true)
            REVISION_EXIT_CODE=$?
            echo "[DEBUG] Exit code: $REVISION_EXIT_CODE"
            echo "[DEBUG] Full output (first 500 chars):"
            echo "$REVISION_OUTPUT" | head -c 500
            echo ""
            
            if [ -n "$REVISION_OUTPUT" ]; then
              echo "[DEBUG] Filtering for edge channel entries..."
              EDGE_LINES=$(echo "$REVISION_OUTPUT" | grep 'edge' || true)
              echo "[DEBUG] Edge channel lines:"
              echo "$EDGE_LINES"
              
              # Look for edge channel entries and get the version
              CURRENT_VERSION=$(echo "$REVISION_OUTPUT" | grep -E '^\s*[0-9]+\s+' | grep 'edge' | head -1 | awk '{print $3}' || true)
              echo "[DEBUG] Extracted version: '$CURRENT_VERSION'"
              
              if [ -n "$CURRENT_VERSION" ]; then
                echo "✓ Found version via list-revisions: $CURRENT_VERSION"
              else
                echo "✗ No version found in list-revisions output"
              fi
            else
              echo "✗ list-revisions returned empty output"
            fi
          else
            echo "✗ snapcraft command not available"
          fi

          # Method 2: Use snapcraft status as fallback
          echo ""
          echo "---- Method 2: snapcraft status (fallback) ----"
          if [ -z "$CURRENT_VERSION" ]; then
            echo "Executing: snapcraft status \"$SNAP_NAME\""
            STATUS_OUTPUT=$(snapcraft status "$SNAP_NAME" 2>&1 || true)
            STATUS_EXIT_CODE=$?
            echo "[DEBUG] Exit code: $STATUS_EXIT_CODE"
            echo "[DEBUG] Full output:"
            echo "$STATUS_OUTPUT"
            
            if [ -n "$STATUS_OUTPUT" ]; then
              echo "[DEBUG] Looking for edge channel line..."
              EDGE_LINE=$(echo "$STATUS_OUTPUT" | grep -E '^\s*edge\s+' || true)
              echo "[DEBUG] Edge line: '$EDGE_LINE'"
              
              # Extract version from edge channel line
              CURRENT_VERSION=$(echo "$STATUS_OUTPUT" | grep -E '^\s*edge\s+' | awk '{print $2}' | cut -d' ' -f1 || true)
              echo "[DEBUG] Extracted version: '$CURRENT_VERSION'"
              
              if [ -n "$CURRENT_VERSION" ]; then
                echo "✓ Found version via status: $CURRENT_VERSION"
              else
                echo "✗ No version found in status output"
              fi
            else
              echo "✗ status command returned empty output"
            fi
          else
            echo "Skipping (already have version: $CURRENT_VERSION)"
          fi

          # Method 3: Use snap info as last resort (less reliable but worth trying)
          echo ""
          echo "---- Method 3: snap info (last resort) ----"
          if [ -z "$CURRENT_VERSION" ]; then
            echo "Executing: snap info \"$SNAP_NAME\""
            SNAP_INFO=$(snap info "$SNAP_NAME" 2>&1 || true)
            INFO_EXIT_CODE=$?
            echo "[DEBUG] Exit code: $INFO_EXIT_CODE"
            echo "[DEBUG] Full output (first 1000 chars):"
            echo "$SNAP_INFO" | head -c 1000
            echo ""
            
            if [ -n "$SNAP_INFO" ]; then
              echo "[DEBUG] Looking for edge channel info..."
              EDGE_SECTION=$(echo "$SNAP_INFO" | grep -A3 'edge:' || true)
              echo "[DEBUG] Edge section:"
              echo "$EDGE_SECTION"
              
              # Look for edge channel version
              CURRENT_VERSION=$(echo "$SNAP_INFO" | grep -A1 'edge:' | tail -1 | awk '{print $1}' | grep -E '^[0-9]+\.[0-9]+' || true)
              echo "[DEBUG] Extracted version: '$CURRENT_VERSION'"
              
              if [ -n "$CURRENT_VERSION" ]; then
                echo "✓ Found version via snap info: $CURRENT_VERSION"
              else
                echo "✗ No version found in snap info output"
              fi
            else
              echo "✗ snap info returned empty output"
            fi
          else
            echo "Skipping (already have version: $CURRENT_VERSION)"
          fi

          # Clean up version string (remove any trailing spaces or special chars)
          echo ""
          echo "==== STEP 4: Cleaning up version string ===="
          echo "[DEBUG] Version before cleanup: '$CURRENT_VERSION'"
          CURRENT_VERSION=$(echo "$CURRENT_VERSION" | tr -d ' ' | sed 's/[^0-9.+]//g')
          echo "[DEBUG] Version after cleanup: '$CURRENT_VERSION'"

          # Decision logic with robust version comparison
          echo ""
          echo "==== STEP 5: Version comparison and decision ===="
          SHOULD_PUBLISH=false

          if [ -z "$CURRENT_VERSION" ]; then
            echo "✓ No existing snap found in store - will publish as first version"
            echo "[DECISION] SHOULD_PUBLISH=true (first release)"
            SHOULD_PUBLISH=true
          else
            echo "Current snap version in edge channel: '$CURRENT_VERSION'"
            echo "New version from pubspec.yaml: '$NEW_VERSION'"
            echo ""
            echo "Running semantic version comparison..."
            
            # Use semantic version comparison
            if compare_versions "$NEW_VERSION" "$CURRENT_VERSION"; then
              echo ""
              echo "✅ RESULT: New version ($NEW_VERSION) is HIGHER than current ($CURRENT_VERSION)"
              echo "[DECISION] SHOULD_PUBLISH=true"
              SHOULD_PUBLISH=true
            elif compare_versions "$CURRENT_VERSION" "$NEW_VERSION"; then
              echo ""
              echo "⚠️  RESULT: New version ($NEW_VERSION) is LOWER than current ($CURRENT_VERSION)"
              echo "WARNING: Version in pubspec.yaml should be bumped!"
              echo "[DECISION] SHOULD_PUBLISH=false"
              SHOULD_PUBLISH=false
            else
              echo ""
              echo "ℹ️  RESULT: Version unchanged ($NEW_VERSION)"
              echo "[DECISION] SHOULD_PUBLISH=false"
              SHOULD_PUBLISH=false
            fi
          fi

          # Publish if needed
          echo ""
          echo "==== STEP 6: Publishing decision ===="
          echo "SHOULD_PUBLISH=$SHOULD_PUBLISH"

          if [ "$SHOULD_PUBLISH" = true ]; then
            echo "Decision: WILL PUBLISH to edge channel"
            echo ""
            echo "==== STEP 7: Finding snap file ===="
            echo "Searching in: ${{ env.BUILD_DIR }}/${{ matrix.client }}/release/"
            
            # List all files in release directory for debugging
            echo "Contents of release directory:"
            ls -la "${{ env.BUILD_DIR }}/${{ matrix.client }}/release/" 2>/dev/null || echo "Directory doesn't exist"
            
            # Find the snap file
            echo ""
            echo "Looking for *.snap files..."
            snap_file=$(find "${{ env.BUILD_DIR }}/${{ matrix.client }}/release/" -name "*.snap" -type f 2>/dev/null | head -1)
            
            if [ -z "$snap_file" ] || [ ! -f "$snap_file" ]; then
              echo "ERROR: No snap file found!"
              echo "Search command: find ${{ env.BUILD_DIR }}/${{ matrix.client }}/release/ -name '*.snap' -type f"
              echo ""
              echo "Full directory tree:"
              find "${{ env.BUILD_DIR }}/${{ matrix.client }}/" -type f -name "*.snap" 2>/dev/null || echo "No snap files found anywhere"
              exit 1
            fi
            
            echo "✓ Found snap file: $snap_file"
            echo "File details:"
            ls -lh "$snap_file"
            echo "File size: $(du -h "$snap_file" | cut -f1)"
            echo "File type: $(file "$snap_file")"
            
            # Upload with error handling
            echo ""
            echo "==== STEP 8: Uploading to snap store ===="
            echo "Executing: snapcraft upload \"$snap_file\" --release edge"
            
            if snapcraft upload "$snap_file" --release edge; then
              echo ""
              echo "=========================================="
              echo "✅ SUCCESS: Published version $NEW_VERSION to edge channel"
              echo "=========================================="
            else
              UPLOAD_EXIT_CODE=$?
              echo ""
              echo "=========================================="
              echo "❌ FAILED: Upload failed with exit code $UPLOAD_EXIT_CODE"
              echo "=========================================="
              exit 1
            fi
          else
            echo "Decision: WILL NOT PUBLISH (no version change)"
            echo ""
            echo "=========================================="
            echo "ℹ️  SKIPPED: No publication needed"
            echo "=========================================="
          fi

          echo ""
          echo "Script completed at: $(date)"

      # List artifacts for verification
      - name: List build artifacts
        run: |
          echo "=== Contents of release directory ==="
          ls -la "${{ env.BUILD_DIR }}/${{ matrix.client }}/release/" || echo "Release directory not found"
          echo "=== End of artifacts list ==="

      - uses: actions/upload-artifact@v4
        with:
          name:
            ${{ matrix.client }}-binaries-${{ runner.os }}${{ matrix.chain != ''
            && format('-{0}', matrix.chain) || '' }}
          if-no-files-found: error
          path: ${{ env.BUILD_DIR }}/${{ matrix.client }}/release/*

  upload-artifacts-to-releases-drivechain-info:
    name: Upload artifacts to releases.drivechain.info
    runs-on: ubuntu-latest
    needs: build
    # Modified if condition to run even with partial failures
    if: |
      always() && 
      github.event_name == 'push' && 
      github.ref == 'refs/heads/master' && 
      github.repository_owner == 'LayerTwo-Labs'
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true

      - name: Check which clients have version changes
        run: |
          # Download existing versions.json from server
          if curl -s -f "https://releases.drivechain.info/versions.json" -o existing_versions.json 2>/dev/null; then
            echo "Downloaded existing versions.json"
          else
            echo "No existing versions.json found, will upload all clients"
            echo "UPLOAD_BITWINDOW=true UPLOAD_BITNAMES=true UPLOAD_BITASSETS=true UPLOAD_THUNDER=true UPLOAD_ZSIDE=true" >> $GITHUB_ENV
            exit 0
          fi
          
          # Find all generated version.json files from artifacts
          version_files=$(find . -name "*-*-version.json" -type f 2>/dev/null || true)
          
          if [ -z "$version_files" ]; then
            echo "No version files found, will upload all clients"
            echo "UPLOAD_BITWINDOW=true UPLOAD_BITNAMES=true UPLOAD_BITASSETS=true UPLOAD_THUNDER=true UPLOAD_ZSIDE=true" >> $GITHUB_ENV
            exit 0
          fi
          
          # Create merged new versions.json from all generated version files
          echo "{}" > new_versions.json
          echo "$version_files" | while read version_file; do
            if [ -n "$version_file" ]; then
              jq -s '.[0] * .[1]' new_versions.json "$version_file" > temp_versions.json
              mv temp_versions.json new_versions.json
            fi
          done
          
          echo "New versions.json:"
          cat new_versions.json | jq .
          echo "Existing versions.json:"
          cat existing_versions.json | jq .
          
          # Compare versions for each client
          for client in bitwindow bitnames bitassets thunder zside; do
            # Get highest version from new and existing
            new_ver=$(jq -r ".$client // {} | to_entries | map(.value.version) | max // \"0.0.0\"" new_versions.json)
            existing_ver=$(jq -r ".$client // {} | to_entries | map(.value.version) | max // \"0.0.0\"" existing_versions.json)
            
            echo "$client: new=$new_ver, existing=$existing_ver"
            
            if [ "$(printf '%s\n' "$new_ver" "$existing_ver" | sort -V | tail -1)" = "$new_ver" ] && [ "$new_ver" != "$existing_ver" ]; then
              echo "UPLOAD_${client^^}=true" >> $GITHUB_ENV
              echo "$client version increased, will upload"
            else
              echo "UPLOAD_${client^^}=false" >> $GITHUB_ENV
              echo "$client version unchanged, will skip"
            fi
          done

      - name: Rename and move artifacts
        working-directory: .
        continue-on-error: true
        run: |
          # Thunder - only rename if version increased
          if [ "$UPLOAD_THUNDER" = "true" ]; then
            echo "Preparing Thunder artifacts for upload..."
            mv thunder-binaries-macOS/thunder-osx64.zip test-thunder-x86_64-apple-darwin.zip || true
            mv thunder-binaries-Linux/thunder-x86_64-linux-gnu.zip test-thunder-x86_64-unknown-linux-gnu.zip || true
            mv thunder-binaries-Linux/Thunder-x86_64.AppImage test-thunder-x86_64-unknown-linux-gnu.AppImage || true
            mv thunder-binaries-Windows/thunder.exe test-thunder-x86_64-windows.exe || true
          else
            echo "Skipping Thunder artifacts (version not increased)"
          fi

          # BitNames - only rename if version increased
          if [ "$UPLOAD_BITNAMES" = "true" ]; then
            echo "Preparing BitNames artifacts for upload..."
            mv bitnames-binaries-macOS/bitnames-osx64.zip test-bitnames-x86_64-apple-darwin.zip || true
            mv bitnames-binaries-Linux/bitnames-x86_64-linux-gnu.zip test-bitnames-x86_64-unknown-linux-gnu.zip || true
            mv bitnames-binaries-Linux/Bitnames-x86_64.AppImage test-bitnames-x86_64-unknown-linux-gnu.AppImage || true
            mv bitnames-binaries-Windows/bitnames.exe test-bitnames-x86_64-windows.exe || true
          else
            echo "Skipping BitNames artifacts (version not increased)"
          fi

          # BitAssets - only rename if version increased
          if [ "$UPLOAD_BITASSETS" = "true" ]; then
            echo "Preparing BitAssets artifacts for upload..."
            mv bitassets-binaries-macOS/bitassets-osx64.zip test-bitassets-x86_64-apple-darwin.zip || true
            mv bitassets-binaries-Linux/bitassets-x86_64-linux-gnu.zip test-bitassets-x86_64-unknown-linux-gnu.zip || true
            mv bitassets-binaries-Linux/BitAssets-x86_64.AppImage test-bitassets-x86_64-unknown-linux-gnu.AppImage || true
            mv bitassets-binaries-Windows/bitassets.exe test-bitassets-x86_64-windows.exe || true
          else
            echo "Skipping BitAssets artifacts (version not increased)"
          fi

          # ZSide - only rename if version increased
          if [ "$UPLOAD_ZSIDE" = "true" ]; then
            echo "Preparing ZSide artifacts for upload..."
            mv zside-binaries-macOS/zside-osx64.zip test-zside-x86_64-apple-darwin.zip || true
            mv zside-binaries-Linux/zside-x86_64-linux-gnu.zip test-zside-x86_64-unknown-linux-gnu.zip || true
            mv zside-binaries-Linux/ZSide-x86_64.AppImage test-zside-x86_64-unknown-linux-gnu.AppImage || true
          else
            echo "Skipping ZSide artifacts (version not increased)"
          fi

          # BitWindow - only rename if version increased
          if [ "$UPLOAD_BITWINDOW" = "true" ]; then
            echo "Preparing BitWindow artifacts for upload..."
            mv bitwindow-binaries-macOS/bitwindow-osx64.zip BitWindow-latest-x86_64-apple-darwin.zip || true
            mv bitwindow-binaries-macOS/bitwindow-osx64.dmg BitWindow-latest-x86_64-apple-darwin.dmg || true
            mv bitwindow-binaries-Linux/bitwindow-x86_64-linux-gnu.zip BitWindow-latest-x86_64-unknown-linux-gnu.zip || true
            mv bitwindow-binaries-Linux/BitWindow-x86_64.AppImage BitWindow-latest-x86_64-unknown-linux-gnu.AppImage || true
            mv bitwindow-binaries-Windows/bitwindow.exe BitWindow-latest-x86_64-windows.exe || true
          else
            echo "Skipping BitWindow artifacts (version not increased)"
          fi

      - name: Install jq for merging version files
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Merge individual version.json files into versions.json
        continue-on-error: true
        run: |
          echo "Downloading existing versions.json..."

          # Download existing versions.json from server
          if curl -s -f "https://releases.drivechain.info/versions.json" -o versions.json 2>/dev/null; then
            echo "Downloaded existing versions.json"
          else
            echo "No existing versions.json found, creating new one"
            echo '{}' > versions.json
          fi

          echo "Merging generated version.json files..."
          echo "Looking for version files in artifact directories..."
          version_files=$(find . -name "*-*-version.json" -type f)

          if [ -z "$version_files" ]; then
            echo "No version files found - keeping existing versions.json"
          else
            echo "Found version files:"
            echo "$version_files"
            
            # Find all generated version.json files and merge them
            echo "$version_files" | while read version_file; do
              if [ -n "$version_file" ]; then
                echo "Merging $version_file..."
                # Use jq to merge the individual version file into the main versions.json
                jq -s '.[0] * .[1]' versions.json "$version_file" > temp_versions.json
                mv temp_versions.json versions.json
              fi
            done
          fi

          echo "Final versions.json:"
          cat versions.json | jq . || echo "Failed to parse versions.json"

      - name: Generate appcast for auto-updater
        continue-on-error: true
        run: |
          # Process appcast fragments for each client
          for client in bitwindow thunder bitnames bitassets zside; do
            echo "Looking for $client appcast fragments in artifact directories..."
            
            macos_fragment=$(find . -name "*${client}*macos*fragment*.xml" -type f 2>/dev/null | head -1 || true)
            windows_fragment=$(find . -name "*${client}*windows*fragment*.xml" -type f 2>/dev/null | head -1 || true)
            
            if [ -n "$macos_fragment" ] || [ -n "$windows_fragment" ]; then
              echo "Found appcast fragments for $client:"
              [ -n "$macos_fragment" ] && echo "  macOS: $macos_fragment"
              [ -n "$windows_fragment" ] && echo "  Windows: $windows_fragment"
              
              # Start building the appcast XML
              echo '<?xml version="1.0" encoding="UTF-8"?>' > "$client-appcast.xml"
              echo '<rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle">' >> "$client-appcast.xml"
              echo '  <channel>' >> "$client-appcast.xml"
              echo "    <title>$client</title>" >> "$client-appcast.xml"
              echo '    <link>https://releases.drivechain.info/</link>' >> "$client-appcast.xml"
              echo "    <description>$client - Drivechain Application</description>" >> "$client-appcast.xml"
              echo '    <language>en</language>' >> "$client-appcast.xml"
              
              # Add Windows fragment if it exists
              if [ -n "$windows_fragment" ] && [ -f "$windows_fragment" ]; then
                echo "    <!-- Windows fragment -->" >> "$client-appcast.xml"
                cat "$windows_fragment" >> "$client-appcast.xml"
              fi
              
              # Add macOS fragment if it exists
              if [ -n "$macos_fragment" ] && [ -f "$macos_fragment" ]; then
                cat "$macos_fragment" >> "$client-appcast.xml"
              fi
              
              # Close the XML
              echo '  </channel>' >> "$client-appcast.xml"
              echo '</rss>' >> "$client-appcast.xml"
              
              echo "Generated $client-appcast.xml"
              cat "$client-appcast.xml"
            else
              echo "No appcast fragments found for $client, skipping"
            fi
          done

      - name: Upload artifacts to releases.drivechain.info
        uses: yitianyigexiangfa/ssh-scp-ssh-pipelines@v1.1.5
        continue-on-error: true
        with:
          host: 45.33.96.47
          user: root
          pass: ${{ secrets.RELEASES_SERVER_PW }}
          port: 22
          scp: |
            'BitWindow-*.exe' => '/var/www/html/'
            'BitWindow-*.zip' => '/var/www/html/'
            'BitWindow-*.dmg' => '/var/www/html/'
            'BitWindow-*.AppImage' => '/var/www/html/'
            'test-*.zip' => '/var/www/html/'
            'test-*.exe' => '/var/www/html/'
            'test-*.AppImage' => '/var/www/html/'
            'versions.json' => '/var/www/html/'
            'bitwindow-appcast.xml' => '/var/www/html/'
            'bitnames-appcast.xml' => '/var/www/html/'
            'bitassets-appcast.xml' => '/var/www/html/'
            'thunder-appcast.xml' => '/var/www/html/'
            'zside-appcast.xml' => '/var/www/html/'
