package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"path/filepath"
	"reflect"
	"time"

	"github.com/rs/zerolog"

	"github.com/LayerTwo-Labs/sidesail/drivechain-frontend/bdk"
)

func main() {
	ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
	defer cancel()

	logger := zerolog.
		New(zerolog.NewConsoleWriter()).
		Level(zerolog.TraceLevel)

	zerolog.DefaultContextLogger = &logger

	if err := realMain(ctx); err != nil {
		cancel()

		zerolog.Ctx(ctx).Fatal().Err(err).Msgf("main: got error")
	}
}

func realMain(ctx context.Context) error {
	// Can be generated by:
	// $ bdk-cli key generate | jq -r .xprv
	priv := "tprv8ZgxMBicQKsPddDC8cJ9WtSuK7rJ8pSiCnSZmydCbuUjWAGxvvCbGcrBnEQgaA5wAynfArkyqK9HNEzzpQ6RnsKChECguDtkkbmRhVLLb3G"

	pwd, err := os.Getwd()
	if err != nil {
		return err
	}

	wallet := bdk.Wallet{
		Datadir:    filepath.Join(pwd, ".data"),
		Descriptor: fmt.Sprintf("wpkh(%s/84h/1h/0h/0/*)", priv),
		Network:    "testnet",
		Electrum:   "ssl://electrum.blockstream.info:60002",
	}

	initialBalance, err := wallet.GetBalance(ctx)
	if err != nil {
		return err
	}

	ticker := time.NewTicker(time.Second * 5)
	defer ticker.Stop()
	go func() {
		for range ticker.C {
			if err := wallet.Sync(ctx); err != nil {
				zerolog.Ctx(ctx).Err(err).Msgf("unable to sync")
				continue
			}

			balance, err := wallet.GetBalance(ctx)
			if err != nil {
				zerolog.Ctx(ctx).Err(err).Msgf("unable to get balance")
				continue
			}

			if reflect.DeepEqual(balance, initialBalance) {
				continue
			}

			zerolog.Ctx(ctx).Info().
				Msgf("balance changed: %+v -> %+v", initialBalance, balance)

			initialBalance = balance
		}
	}()

	select {
	case <-ctx.Done():
		return ctx.Err()

	case <-time.After(time.Hour):

	}

	return nil
}
