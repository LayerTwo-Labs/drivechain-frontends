package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"path/filepath"
	"reflect"
	"time"

	"connectrpc.com/connect"
	"github.com/LayerTwo-Labs/sidesail/drivechain-server/bdk"
	pb "github.com/barebitcoin/btc-buf/gen/bitcoin/bitcoind/v1alpha"
	coreproxy "github.com/barebitcoin/btc-buf/server"
	"github.com/btcsuite/btcd/btcutil"
	"github.com/rs/zerolog"
)

func main() {
	ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
	defer cancel()

	logger := zerolog.
		New(zerolog.NewConsoleWriter()).
		Level(zerolog.TraceLevel)

	zerolog.DefaultContextLogger = &logger

	if err := realMain(ctx); err != nil {
		cancel()

		zerolog.Ctx(ctx).Fatal().Err(err).Msgf("main: got error")
	}
}

func realMain(ctx context.Context) error {
	proxy, err := startCoreProxy(ctx)
	if err != nil {
		return err
	}

	info, err := proxy.GetBlockchainInfo(ctx, connect.NewRequest(&pb.GetBlockchainInfoRequest{}))
	if err != nil {
		return err
	}

	zerolog.Ctx(ctx).Info().Msgf("blockchain info: %s", info.Msg.String())

	// Can be generated by:
	// $ bdk-cli key generate | jq -r .xprv
	priv := "tprv8ZgxMBicQKsPddDC8cJ9WtSuK7rJ8pSiCnSZmydCbuUjWAGxvvCbGcrBnEQgaA5wAynfArkyqK9HNEzzpQ6RnsKChECguDtkkbmRhVLLb3G"

	pwd, err := os.Getwd()
	if err != nil {
		return err
	}

	wallet := bdk.Wallet{
		Datadir:    filepath.Join(pwd, ".data"),
		Descriptor: fmt.Sprintf("wpkh(%s/84h/1h/0h/0/*)", priv),
		Network:    "testnet",
		Electrum:   "ssl://electrum.blockstream.info:60002",
	}

	initialBalance, err := wallet.GetBalance(ctx)
	if err != nil {
		return err
	}

	ticker := time.NewTicker(time.Second * 5)
	defer ticker.Stop()
	go func() {
		for range ticker.C {
			if err := wallet.Sync(ctx); err != nil {
				zerolog.Ctx(ctx).Err(err).Msgf("unable to sync")
				continue
			}

			balance, err := wallet.GetBalance(ctx)
			if err != nil {
				zerolog.Ctx(ctx).Err(err).Msgf("unable to get balance")
				continue
			}

			if reflect.DeepEqual(balance, initialBalance) {
				continue
			}

			zerolog.Ctx(ctx).Info().
				Msgf("balance changed: %+v -> %+v", initialBalance, balance)

			initialBalance = balance
		}
	}()

	created, err := wallet.CreateTransaction(ctx, map[string]btcutil.Amount{
		"tb1qacfxjrngh2s2qavh0s8q9w272ze77daq4a6nef": 1000,
	}, 20)
	if err != nil {
		return err
	}

	signed, err := wallet.SignTransaction(ctx, created)
	if err != nil {
		return err
	}

	txid, err := wallet.BroadcastTransaction(ctx, signed)
	if err != nil {
		return err
	}

	zerolog.Ctx(ctx).Info().Msgf("sent transaction: %s", txid)

	select {
	case <-ctx.Done():
		return ctx.Err()

	case <-time.After(time.Hour):

	}

	return nil
}

func startCoreProxy(ctx context.Context) (*coreproxy.Bitcoind, error) {
	core, err := coreproxy.NewBitcoind(ctx, "localhost:18332", "__cookie__", "03b6af00caa0d2667e81e56dd5d4f14fe12b6b6f6c0c86e81bf251aa0d69beb0")
	if err != nil {
		return nil, err
	}

	return core, nil
}
