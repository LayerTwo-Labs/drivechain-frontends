// @generated by protoc-gen-es v2.10.1 with parameter "target=js+dts,json_types=true"
// @generated from file bitcoin/bitcoind/v1alpha/bitcoin.proto (package bitcoin.bitcoind.v1alpha, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { BoolValueJson, EmptySchema, Timestamp, TimestampJson } from "@bufbuild/protobuf/wkt";

/**
 * Describes the file bitcoin/bitcoind/v1alpha/bitcoin.proto.
 */
export declare const file_bitcoin_bitcoind_v1alpha_bitcoin: GenFile;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBlockchainInfoRequest
 */
export declare type GetBlockchainInfoRequest = Message<"bitcoin.bitcoind.v1alpha.GetBlockchainInfoRequest"> & {
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBlockchainInfoRequest
 */
export declare type GetBlockchainInfoRequestJson = {
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetBlockchainInfoRequest.
 * Use `create(GetBlockchainInfoRequestSchema)` to create a new message.
 */
export declare const GetBlockchainInfoRequestSchema: GenMessage<GetBlockchainInfoRequest, {jsonType: GetBlockchainInfoRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBlockchainInfoResponse
 */
export declare type GetBlockchainInfoResponse = Message<"bitcoin.bitcoind.v1alpha.GetBlockchainInfoResponse"> & {
  /**
   * @generated from field: string best_block_hash = 1;
   */
  bestBlockHash: string;

  /**
   * The height of the most-work fully-validated chain.
   *
   * @generated from field: uint32 blocks = 5;
   */
  blocks: number;

  /**
   * The current number of validated headers.
   *
   * @generated from field: uint32 headers = 6;
   */
  headers: number;

  /**
   * @generated from field: string chain = 2;
   */
  chain: string;

  /**
   * @generated from field: string chain_work = 3;
   */
  chainWork: string;

  /**
   * @generated from field: bool initial_block_download = 4;
   */
  initialBlockDownload: boolean;

  /**
   * @generated from field: double verification_progress = 7;
   */
  verificationProgress: number;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBlockchainInfoResponse
 */
export declare type GetBlockchainInfoResponseJson = {
  /**
   * @generated from field: string best_block_hash = 1;
   */
  bestBlockHash?: string;

  /**
   * The height of the most-work fully-validated chain.
   *
   * @generated from field: uint32 blocks = 5;
   */
  blocks?: number;

  /**
   * The current number of validated headers.
   *
   * @generated from field: uint32 headers = 6;
   */
  headers?: number;

  /**
   * @generated from field: string chain = 2;
   */
  chain?: string;

  /**
   * @generated from field: string chain_work = 3;
   */
  chainWork?: string;

  /**
   * @generated from field: bool initial_block_download = 4;
   */
  initialBlockDownload?: boolean;

  /**
   * @generated from field: double verification_progress = 7;
   */
  verificationProgress?: number | "NaN" | "Infinity" | "-Infinity";
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetBlockchainInfoResponse.
 * Use `create(GetBlockchainInfoResponseSchema)` to create a new message.
 */
export declare const GetBlockchainInfoResponseSchema: GenMessage<GetBlockchainInfoResponse, {jsonType: GetBlockchainInfoResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetPeerInfoRequest
 */
export declare type GetPeerInfoRequest = Message<"bitcoin.bitcoind.v1alpha.GetPeerInfoRequest"> & {
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetPeerInfoRequest
 */
export declare type GetPeerInfoRequestJson = {
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetPeerInfoRequest.
 * Use `create(GetPeerInfoRequestSchema)` to create a new message.
 */
export declare const GetPeerInfoRequestSchema: GenMessage<GetPeerInfoRequest, {jsonType: GetPeerInfoRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.Peer
 */
export declare type Peer = Message<"bitcoin.bitcoind.v1alpha.Peer"> & {
  /**
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * @generated from field: string addr = 2;
   */
  addr: string;

  /**
   * @generated from field: int32 synced_blocks = 3;
   */
  syncedBlocks: number;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.Peer
 */
export declare type PeerJson = {
  /**
   * @generated from field: int32 id = 1;
   */
  id?: number;

  /**
   * @generated from field: string addr = 2;
   */
  addr?: string;

  /**
   * @generated from field: int32 synced_blocks = 3;
   */
  syncedBlocks?: number;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.Peer.
 * Use `create(PeerSchema)` to create a new message.
 */
export declare const PeerSchema: GenMessage<Peer, {jsonType: PeerJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetPeerInfoResponse
 */
export declare type GetPeerInfoResponse = Message<"bitcoin.bitcoind.v1alpha.GetPeerInfoResponse"> & {
  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.Peer peers = 1;
   */
  peers: Peer[];
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetPeerInfoResponse
 */
export declare type GetPeerInfoResponseJson = {
  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.Peer peers = 1;
   */
  peers?: PeerJson[];
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetPeerInfoResponse.
 * Use `create(GetPeerInfoResponseSchema)` to create a new message.
 */
export declare const GetPeerInfoResponseSchema: GenMessage<GetPeerInfoResponse, {jsonType: GetPeerInfoResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetNewAddressRequest
 */
export declare type GetNewAddressRequest = Message<"bitcoin.bitcoind.v1alpha.GetNewAddressRequest"> & {
  /**
   * @generated from field: string label = 1;
   */
  label: string;

  /**
   * @generated from field: string address_type = 2;
   */
  addressType: string;

  /**
   * Only needs to be set if dealing with multiple wallets at the same time.
   * TODO: better suited as a header?
   *
   * @generated from field: string wallet = 3;
   */
  wallet: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetNewAddressRequest
 */
export declare type GetNewAddressRequestJson = {
  /**
   * @generated from field: string label = 1;
   */
  label?: string;

  /**
   * @generated from field: string address_type = 2;
   */
  addressType?: string;

  /**
   * Only needs to be set if dealing with multiple wallets at the same time.
   * TODO: better suited as a header?
   *
   * @generated from field: string wallet = 3;
   */
  wallet?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetNewAddressRequest.
 * Use `create(GetNewAddressRequestSchema)` to create a new message.
 */
export declare const GetNewAddressRequestSchema: GenMessage<GetNewAddressRequest, {jsonType: GetNewAddressRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetNewAddressResponse
 */
export declare type GetNewAddressResponse = Message<"bitcoin.bitcoind.v1alpha.GetNewAddressResponse"> & {
  /**
   * @generated from field: string address = 1;
   */
  address: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetNewAddressResponse
 */
export declare type GetNewAddressResponseJson = {
  /**
   * @generated from field: string address = 1;
   */
  address?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetNewAddressResponse.
 * Use `create(GetNewAddressResponseSchema)` to create a new message.
 */
export declare const GetNewAddressResponseSchema: GenMessage<GetNewAddressResponse, {jsonType: GetNewAddressResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetWalletInfoRequest
 */
export declare type GetWalletInfoRequest = Message<"bitcoin.bitcoind.v1alpha.GetWalletInfoRequest"> & {
  /**
   * Only needs to be set if dealing with multiple wallets at the same time.
   * TODO: better suited as a header?
   *
   * @generated from field: string wallet = 1;
   */
  wallet: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetWalletInfoRequest
 */
export declare type GetWalletInfoRequestJson = {
  /**
   * Only needs to be set if dealing with multiple wallets at the same time.
   * TODO: better suited as a header?
   *
   * @generated from field: string wallet = 1;
   */
  wallet?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetWalletInfoRequest.
 * Use `create(GetWalletInfoRequestSchema)` to create a new message.
 */
export declare const GetWalletInfoRequestSchema: GenMessage<GetWalletInfoRequest, {jsonType: GetWalletInfoRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetWalletInfoResponse
 */
export declare type GetWalletInfoResponse = Message<"bitcoin.bitcoind.v1alpha.GetWalletInfoResponse"> & {
  /**
   * @generated from field: string wallet_name = 1;
   */
  walletName: string;

  /**
   * @generated from field: int64 wallet_version = 2;
   */
  walletVersion: bigint;

  /**
   * @generated from field: string format = 3;
   */
  format: string;

  /**
   * @generated from field: int64 tx_count = 7;
   */
  txCount: bigint;

  /**
   * @generated from field: int64 key_pool_size = 8;
   */
  keyPoolSize: bigint;

  /**
   * @generated from field: int64 key_pool_size_hd_internal = 9;
   */
  keyPoolSizeHdInternal: bigint;

  /**
   * @generated from field: double pay_tx_fee = 10;
   */
  payTxFee: number;

  /**
   * @generated from field: bool private_keys_enabled = 11;
   */
  privateKeysEnabled: boolean;

  /**
   * @generated from field: bool avoid_reuse = 12;
   */
  avoidReuse: boolean;

  /**
   * Not set if no scan is in progress.
   *
   * @generated from field: bitcoin.bitcoind.v1alpha.WalletScan scanning = 13;
   */
  scanning?: WalletScan;

  /**
   * @generated from field: bool descriptors = 14;
   */
  descriptors: boolean;

  /**
   * @generated from field: bool external_signer = 15;
   */
  externalSigner: boolean;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetWalletInfoResponse
 */
export declare type GetWalletInfoResponseJson = {
  /**
   * @generated from field: string wallet_name = 1;
   */
  walletName?: string;

  /**
   * @generated from field: int64 wallet_version = 2;
   */
  walletVersion?: string;

  /**
   * @generated from field: string format = 3;
   */
  format?: string;

  /**
   * @generated from field: int64 tx_count = 7;
   */
  txCount?: string;

  /**
   * @generated from field: int64 key_pool_size = 8;
   */
  keyPoolSize?: string;

  /**
   * @generated from field: int64 key_pool_size_hd_internal = 9;
   */
  keyPoolSizeHdInternal?: string;

  /**
   * @generated from field: double pay_tx_fee = 10;
   */
  payTxFee?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * @generated from field: bool private_keys_enabled = 11;
   */
  privateKeysEnabled?: boolean;

  /**
   * @generated from field: bool avoid_reuse = 12;
   */
  avoidReuse?: boolean;

  /**
   * Not set if no scan is in progress.
   *
   * @generated from field: bitcoin.bitcoind.v1alpha.WalletScan scanning = 13;
   */
  scanning?: WalletScanJson;

  /**
   * @generated from field: bool descriptors = 14;
   */
  descriptors?: boolean;

  /**
   * @generated from field: bool external_signer = 15;
   */
  externalSigner?: boolean;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetWalletInfoResponse.
 * Use `create(GetWalletInfoResponseSchema)` to create a new message.
 */
export declare const GetWalletInfoResponseSchema: GenMessage<GetWalletInfoResponse, {jsonType: GetWalletInfoResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBalancesRequest
 */
export declare type GetBalancesRequest = Message<"bitcoin.bitcoind.v1alpha.GetBalancesRequest"> & {
  /**
   * @generated from field: string wallet = 1;
   */
  wallet: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBalancesRequest
 */
export declare type GetBalancesRequestJson = {
  /**
   * @generated from field: string wallet = 1;
   */
  wallet?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetBalancesRequest.
 * Use `create(GetBalancesRequestSchema)` to create a new message.
 */
export declare const GetBalancesRequestSchema: GenMessage<GetBalancesRequest, {jsonType: GetBalancesRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBalancesResponse
 */
export declare type GetBalancesResponse = Message<"bitcoin.bitcoind.v1alpha.GetBalancesResponse"> & {
  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.GetBalancesResponse.Mine mine = 1;
   */
  mine?: GetBalancesResponse_Mine;

  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.GetBalancesResponse.Watchonly watchonly = 2;
   */
  watchonly?: GetBalancesResponse_Watchonly;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBalancesResponse
 */
export declare type GetBalancesResponseJson = {
  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.GetBalancesResponse.Mine mine = 1;
   */
  mine?: GetBalancesResponse_MineJson;

  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.GetBalancesResponse.Watchonly watchonly = 2;
   */
  watchonly?: GetBalancesResponse_WatchonlyJson;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetBalancesResponse.
 * Use `create(GetBalancesResponseSchema)` to create a new message.
 */
export declare const GetBalancesResponseSchema: GenMessage<GetBalancesResponse, {jsonType: GetBalancesResponseJson}>;

/**
 * balances from outputs that the wallet can sign
 *
 * @generated from message bitcoin.bitcoind.v1alpha.GetBalancesResponse.Mine
 */
export declare type GetBalancesResponse_Mine = Message<"bitcoin.bitcoind.v1alpha.GetBalancesResponse.Mine"> & {
  /**
   * trusted balance (outputs created by the wallet or confirmed outputs)
   *
   * @generated from field: double trusted = 1;
   */
  trusted: number;

  /**
   * untrusted pending balance (outputs created by others that are in the mempool)
   *
   * @generated from field: double untrusted_pending = 2;
   */
  untrustedPending: number;

  /**
   * balance from immature coinbase outputs
   *
   * @generated from field: double immature = 3;
   */
  immature: number;

  /**
   * only present if avoid_reuse is set) balance from coins sent to addresses that were previously spent from (potentially privacy violating
   *
   * @generated from field: double used = 4;
   */
  used: number;
};

/**
 * balances from outputs that the wallet can sign
 *
 * @generated from message bitcoin.bitcoind.v1alpha.GetBalancesResponse.Mine
 */
export declare type GetBalancesResponse_MineJson = {
  /**
   * trusted balance (outputs created by the wallet or confirmed outputs)
   *
   * @generated from field: double trusted = 1;
   */
  trusted?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * untrusted pending balance (outputs created by others that are in the mempool)
   *
   * @generated from field: double untrusted_pending = 2;
   */
  untrustedPending?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * balance from immature coinbase outputs
   *
   * @generated from field: double immature = 3;
   */
  immature?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * only present if avoid_reuse is set) balance from coins sent to addresses that were previously spent from (potentially privacy violating
   *
   * @generated from field: double used = 4;
   */
  used?: number | "NaN" | "Infinity" | "-Infinity";
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetBalancesResponse.Mine.
 * Use `create(GetBalancesResponse_MineSchema)` to create a new message.
 */
export declare const GetBalancesResponse_MineSchema: GenMessage<GetBalancesResponse_Mine, {jsonType: GetBalancesResponse_MineJson}>;

/**
 * watchonly balances (not present if wallet does not watch anything)
 *
 * @generated from message bitcoin.bitcoind.v1alpha.GetBalancesResponse.Watchonly
 */
export declare type GetBalancesResponse_Watchonly = Message<"bitcoin.bitcoind.v1alpha.GetBalancesResponse.Watchonly"> & {
  /**
   * trusted balance (outputs created by the wallet or confirmed outputs)
   *
   * @generated from field: double trusted = 1;
   */
  trusted: number;

  /**
   * untrusted pending balance (outputs created by others that are in the mempool)
   *
   * @generated from field: double untrusted_pending = 2;
   */
  untrustedPending: number;

  /**
   * balance from immature coinbase outputs
   *
   * @generated from field: double immature = 3;
   */
  immature: number;
};

/**
 * watchonly balances (not present if wallet does not watch anything)
 *
 * @generated from message bitcoin.bitcoind.v1alpha.GetBalancesResponse.Watchonly
 */
export declare type GetBalancesResponse_WatchonlyJson = {
  /**
   * trusted balance (outputs created by the wallet or confirmed outputs)
   *
   * @generated from field: double trusted = 1;
   */
  trusted?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * untrusted pending balance (outputs created by others that are in the mempool)
   *
   * @generated from field: double untrusted_pending = 2;
   */
  untrustedPending?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * balance from immature coinbase outputs
   *
   * @generated from field: double immature = 3;
   */
  immature?: number | "NaN" | "Infinity" | "-Infinity";
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetBalancesResponse.Watchonly.
 * Use `create(GetBalancesResponse_WatchonlySchema)` to create a new message.
 */
export declare const GetBalancesResponse_WatchonlySchema: GenMessage<GetBalancesResponse_Watchonly, {jsonType: GetBalancesResponse_WatchonlyJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.WalletScan
 */
export declare type WalletScan = Message<"bitcoin.bitcoind.v1alpha.WalletScan"> & {
  /**
   * @generated from field: int64 duration = 1;
   */
  duration: bigint;

  /**
   * @generated from field: double progress = 2;
   */
  progress: number;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.WalletScan
 */
export declare type WalletScanJson = {
  /**
   * @generated from field: int64 duration = 1;
   */
  duration?: string;

  /**
   * @generated from field: double progress = 2;
   */
  progress?: number | "NaN" | "Infinity" | "-Infinity";
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.WalletScan.
 * Use `create(WalletScanSchema)` to create a new message.
 */
export declare const WalletScanSchema: GenMessage<WalletScan, {jsonType: WalletScanJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetTransactionRequest
 */
export declare type GetTransactionRequest = Message<"bitcoin.bitcoind.v1alpha.GetTransactionRequest"> & {
  /**
   * @generated from field: string txid = 1;
   */
  txid: string;

  /**
   * @generated from field: bool include_watchonly = 2;
   */
  includeWatchonly: boolean;

  /**
   * @generated from field: bool verbose = 3;
   */
  verbose: boolean;

  /**
   * @generated from field: string wallet = 4;
   */
  wallet: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetTransactionRequest
 */
export declare type GetTransactionRequestJson = {
  /**
   * @generated from field: string txid = 1;
   */
  txid?: string;

  /**
   * @generated from field: bool include_watchonly = 2;
   */
  includeWatchonly?: boolean;

  /**
   * @generated from field: bool verbose = 3;
   */
  verbose?: boolean;

  /**
   * @generated from field: string wallet = 4;
   */
  wallet?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetTransactionRequest.
 * Use `create(GetTransactionRequestSchema)` to create a new message.
 */
export declare const GetTransactionRequestSchema: GenMessage<GetTransactionRequest, {jsonType: GetTransactionRequestJson}>;

/**
 * Commented fields are not present in btcd/rpcclient
 *
 * @generated from message bitcoin.bitcoind.v1alpha.GetTransactionResponse
 */
export declare type GetTransactionResponse = Message<"bitcoin.bitcoind.v1alpha.GetTransactionResponse"> & {
  /**
   * @generated from field: double amount = 1;
   */
  amount: number;

  /**
   * @generated from field: double fee = 2;
   */
  fee: number;

  /**
   * The number of confirmations for the transaction. Negative
   * confirmations means the transaction conflicted that many
   * blocks ago.
   *
   * @generated from field: int32 confirmations = 3;
   */
  confirmations: number;

  /**
   * bool generated = 4;
   * bool trusted = 5;
   *
   * @generated from field: string block_hash = 6;
   */
  blockHash: string;

  /**
   * string block_height = 7;
   *
   * @generated from field: uint32 block_index = 8;
   */
  blockIndex: number;

  /**
   * @generated from field: google.protobuf.Timestamp block_time = 9;
   */
  blockTime?: Timestamp;

  /**
   * @generated from field: string txid = 10;
   */
  txid: string;

  /**
   * string witness_txid = 11;
   *
   * @generated from field: repeated string wallet_conflicts = 12;
   */
  walletConflicts: string[];

  /**
   * @generated from field: string replaced_by_txid = 13;
   */
  replacedByTxid: string;

  /**
   * @generated from field: string replaces_txid = 14;
   */
  replacesTxid: string;

  /**
   * string comment = 15;
   * string to = 16;
   *
   * @generated from field: google.protobuf.Timestamp time = 17;
   */
  time?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp time_received = 18;
   */
  timeReceived?: Timestamp;

  /**
   * Whether this transaction signals BIP125 (Replace-by-fee, RBF) replaceability
   * or has an unconfirmed ancestor signaling BIP125 replaceability. May be unspecified
   * for unconfirmed transactions not in the mempool because their
   * unconfirmed ancestors are unknown.
   *
   * Note that this is always set to 'no' once the transaction is confirmed.
   *
   * @generated from field: bitcoin.bitcoind.v1alpha.GetTransactionResponse.Replaceable bip125_replaceable = 19;
   */
  bip125Replaceable: GetTransactionResponse_Replaceable;

  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.GetTransactionResponse.Details details = 21;
   */
  details: GetTransactionResponse_Details[];

  /**
   * @generated from field: string hex = 22;
   */
  hex: string;
};

/**
 * Commented fields are not present in btcd/rpcclient
 *
 * @generated from message bitcoin.bitcoind.v1alpha.GetTransactionResponse
 */
export declare type GetTransactionResponseJson = {
  /**
   * @generated from field: double amount = 1;
   */
  amount?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * @generated from field: double fee = 2;
   */
  fee?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * The number of confirmations for the transaction. Negative
   * confirmations means the transaction conflicted that many
   * blocks ago.
   *
   * @generated from field: int32 confirmations = 3;
   */
  confirmations?: number;

  /**
   * bool generated = 4;
   * bool trusted = 5;
   *
   * @generated from field: string block_hash = 6;
   */
  blockHash?: string;

  /**
   * string block_height = 7;
   *
   * @generated from field: uint32 block_index = 8;
   */
  blockIndex?: number;

  /**
   * @generated from field: google.protobuf.Timestamp block_time = 9;
   */
  blockTime?: TimestampJson;

  /**
   * @generated from field: string txid = 10;
   */
  txid?: string;

  /**
   * string witness_txid = 11;
   *
   * @generated from field: repeated string wallet_conflicts = 12;
   */
  walletConflicts?: string[];

  /**
   * @generated from field: string replaced_by_txid = 13;
   */
  replacedByTxid?: string;

  /**
   * @generated from field: string replaces_txid = 14;
   */
  replacesTxid?: string;

  /**
   * string comment = 15;
   * string to = 16;
   *
   * @generated from field: google.protobuf.Timestamp time = 17;
   */
  time?: TimestampJson;

  /**
   * @generated from field: google.protobuf.Timestamp time_received = 18;
   */
  timeReceived?: TimestampJson;

  /**
   * Whether this transaction signals BIP125 (Replace-by-fee, RBF) replaceability
   * or has an unconfirmed ancestor signaling BIP125 replaceability. May be unspecified
   * for unconfirmed transactions not in the mempool because their
   * unconfirmed ancestors are unknown.
   *
   * Note that this is always set to 'no' once the transaction is confirmed.
   *
   * @generated from field: bitcoin.bitcoind.v1alpha.GetTransactionResponse.Replaceable bip125_replaceable = 19;
   */
  bip125Replaceable?: GetTransactionResponse_ReplaceableJson;

  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.GetTransactionResponse.Details details = 21;
   */
  details?: GetTransactionResponse_DetailsJson[];

  /**
   * @generated from field: string hex = 22;
   */
  hex?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetTransactionResponse.
 * Use `create(GetTransactionResponseSchema)` to create a new message.
 */
export declare const GetTransactionResponseSchema: GenMessage<GetTransactionResponse, {jsonType: GetTransactionResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetTransactionResponse.Details
 */
export declare type GetTransactionResponse_Details = Message<"bitcoin.bitcoind.v1alpha.GetTransactionResponse.Details"> & {
  /**
   * @generated from field: bool involves_watch_only = 1;
   */
  involvesWatchOnly: boolean;

  /**
   * @generated from field: string address = 2;
   */
  address: string;

  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.GetTransactionResponse.Category category = 3;
   */
  category: GetTransactionResponse_Category;

  /**
   * @generated from field: double amount = 4;
   */
  amount: number;

  /**
   * string label = 5;
   *
   * @generated from field: uint32 vout = 6;
   */
  vout: number;

  /**
   * bool abandoned = 8;
   * repeated string parent_descriptors = 9;
   *
   * @generated from field: double fee = 7;
   */
  fee: number;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetTransactionResponse.Details
 */
export declare type GetTransactionResponse_DetailsJson = {
  /**
   * @generated from field: bool involves_watch_only = 1;
   */
  involvesWatchOnly?: boolean;

  /**
   * @generated from field: string address = 2;
   */
  address?: string;

  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.GetTransactionResponse.Category category = 3;
   */
  category?: GetTransactionResponse_CategoryJson;

  /**
   * @generated from field: double amount = 4;
   */
  amount?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * string label = 5;
   *
   * @generated from field: uint32 vout = 6;
   */
  vout?: number;

  /**
   * bool abandoned = 8;
   * repeated string parent_descriptors = 9;
   *
   * @generated from field: double fee = 7;
   */
  fee?: number | "NaN" | "Infinity" | "-Infinity";
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetTransactionResponse.Details.
 * Use `create(GetTransactionResponse_DetailsSchema)` to create a new message.
 */
export declare const GetTransactionResponse_DetailsSchema: GenMessage<GetTransactionResponse_Details, {jsonType: GetTransactionResponse_DetailsJson}>;

/**
 * @generated from enum bitcoin.bitcoind.v1alpha.GetTransactionResponse.Replaceable
 */
export enum GetTransactionResponse_Replaceable {
  /**
   * @generated from enum value: REPLACEABLE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: REPLACEABLE_YES = 1;
   */
  YES = 1,

  /**
   * @generated from enum value: REPLACEABLE_NO = 2;
   */
  NO = 2,
}

/**
 * @generated from enum bitcoin.bitcoind.v1alpha.GetTransactionResponse.Replaceable
 */
export declare type GetTransactionResponse_ReplaceableJson = "REPLACEABLE_UNSPECIFIED" | "REPLACEABLE_YES" | "REPLACEABLE_NO";

/**
 * Describes the enum bitcoin.bitcoind.v1alpha.GetTransactionResponse.Replaceable.
 */
export declare const GetTransactionResponse_ReplaceableSchema: GenEnum<GetTransactionResponse_Replaceable, GetTransactionResponse_ReplaceableJson>;

/**
 * @generated from enum bitcoin.bitcoind.v1alpha.GetTransactionResponse.Category
 */
export enum GetTransactionResponse_Category {
  /**
   * @generated from enum value: CATEGORY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CATEGORY_SEND = 1;
   */
  SEND = 1,

  /**
   * @generated from enum value: CATEGORY_RECEIVE = 2;
   */
  RECEIVE = 2,

  /**
   * @generated from enum value: CATEGORY_GENERATE = 3;
   */
  GENERATE = 3,

  /**
   * @generated from enum value: CATEGORY_IMMATURE = 4;
   */
  IMMATURE = 4,

  /**
   * @generated from enum value: CATEGORY_ORPHAN = 5;
   */
  ORPHAN = 5,
}

/**
 * @generated from enum bitcoin.bitcoind.v1alpha.GetTransactionResponse.Category
 */
export declare type GetTransactionResponse_CategoryJson = "CATEGORY_UNSPECIFIED" | "CATEGORY_SEND" | "CATEGORY_RECEIVE" | "CATEGORY_GENERATE" | "CATEGORY_IMMATURE" | "CATEGORY_ORPHAN";

/**
 * Describes the enum bitcoin.bitcoind.v1alpha.GetTransactionResponse.Category.
 */
export declare const GetTransactionResponse_CategorySchema: GenEnum<GetTransactionResponse_Category, GetTransactionResponse_CategoryJson>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetRawTransactionRequest
 */
export declare type GetRawTransactionRequest = Message<"bitcoin.bitcoind.v1alpha.GetRawTransactionRequest"> & {
  /**
   * The transaction ID. Required.
   *
   * @generated from field: string txid = 1;
   */
  txid: string;

  /**
   * If false, returns just the hex string. Otherwise, returns the complete object.
   *
   * @generated from field: bool verbose = 2;
   */
  verbose: boolean;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetRawTransactionRequest
 */
export declare type GetRawTransactionRequestJson = {
  /**
   * The transaction ID. Required.
   *
   * @generated from field: string txid = 1;
   */
  txid?: string;

  /**
   * If false, returns just the hex string. Otherwise, returns the complete object.
   *
   * @generated from field: bool verbose = 2;
   */
  verbose?: boolean;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetRawTransactionRequest.
 * Use `create(GetRawTransactionRequestSchema)` to create a new message.
 */
export declare const GetRawTransactionRequestSchema: GenMessage<GetRawTransactionRequest, {jsonType: GetRawTransactionRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.Input
 */
export declare type Input = Message<"bitcoin.bitcoind.v1alpha.Input"> & {
  /**
   * @generated from field: string txid = 1;
   */
  txid: string;

  /**
   * @generated from field: uint32 vout = 2;
   */
  vout: number;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.Input
 */
export declare type InputJson = {
  /**
   * @generated from field: string txid = 1;
   */
  txid?: string;

  /**
   * @generated from field: uint32 vout = 2;
   */
  vout?: number;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.Input.
 * Use `create(InputSchema)` to create a new message.
 */
export declare const InputSchema: GenMessage<Input, {jsonType: InputJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ScriptPubKey
 */
export declare type ScriptPubKey = Message<"bitcoin.bitcoind.v1alpha.ScriptPubKey"> & {
  /**
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * @generated from field: string address = 2;
   */
  address: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ScriptPubKey
 */
export declare type ScriptPubKeyJson = {
  /**
   * @generated from field: string type = 1;
   */
  type?: string;

  /**
   * @generated from field: string address = 2;
   */
  address?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.ScriptPubKey.
 * Use `create(ScriptPubKeySchema)` to create a new message.
 */
export declare const ScriptPubKeySchema: GenMessage<ScriptPubKey, {jsonType: ScriptPubKeyJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.Output
 */
export declare type Output = Message<"bitcoin.bitcoind.v1alpha.Output"> & {
  /**
   * @generated from field: double amount = 1;
   */
  amount: number;

  /**
   * The output index
   *
   * @generated from field: uint32 n = 2;
   */
  n: number;

  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.ScriptPubKey script_pub_key = 3;
   */
  scriptPubKey?: ScriptPubKey;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.Output
 */
export declare type OutputJson = {
  /**
   * @generated from field: double amount = 1;
   */
  amount?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * The output index
   *
   * @generated from field: uint32 n = 2;
   */
  n?: number;

  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.ScriptPubKey script_pub_key = 3;
   */
  scriptPubKey?: ScriptPubKeyJson;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.Output.
 * Use `create(OutputSchema)` to create a new message.
 */
export declare const OutputSchema: GenMessage<Output, {jsonType: OutputJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetRawTransactionResponse
 */
export declare type GetRawTransactionResponse = Message<"bitcoin.bitcoind.v1alpha.GetRawTransactionResponse"> & {
  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.RawTransaction tx = 1;
   */
  tx?: RawTransaction;

  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.Input inputs = 2;
   */
  inputs: Input[];

  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.Output outputs = 3;
   */
  outputs: Output[];

  /**
   * @generated from field: string blockhash = 4;
   */
  blockhash: string;

  /**
   * @generated from field: uint32 confirmations = 5;
   */
  confirmations: number;

  /**
   * @generated from field: int64 time = 6;
   */
  time: bigint;

  /**
   * @generated from field: int64 blocktime = 7;
   */
  blocktime: bigint;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetRawTransactionResponse
 */
export declare type GetRawTransactionResponseJson = {
  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.RawTransaction tx = 1;
   */
  tx?: RawTransactionJson;

  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.Input inputs = 2;
   */
  inputs?: InputJson[];

  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.Output outputs = 3;
   */
  outputs?: OutputJson[];

  /**
   * @generated from field: string blockhash = 4;
   */
  blockhash?: string;

  /**
   * @generated from field: uint32 confirmations = 5;
   */
  confirmations?: number;

  /**
   * @generated from field: int64 time = 6;
   */
  time?: string;

  /**
   * @generated from field: int64 blocktime = 7;
   */
  blocktime?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetRawTransactionResponse.
 * Use `create(GetRawTransactionResponseSchema)` to create a new message.
 */
export declare const GetRawTransactionResponseSchema: GenMessage<GetRawTransactionResponse, {jsonType: GetRawTransactionResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.SendRequest
 */
export declare type SendRequest = Message<"bitcoin.bitcoind.v1alpha.SendRequest"> & {
  /**
   * bitcoin address -> BTC amount
   *
   * @generated from field: map<string, double> destinations = 1;
   */
  destinations: { [key: string]: number };

  /**
   * Confirmation target in blocks.
   *
   * @generated from field: uint32 conf_target = 2;
   */
  confTarget: number;

  /**
   * Only needs to be set if dealing with multiple wallets at the same time.
   * TODO: better suited as a header?
   *
   * @generated from field: string wallet = 3;
   */
  wallet: string;

  /**
   * Include inputs that are not safe to spend (unconfirmed transactions from
   * outside keys and unconfirmed replacement transactions.
   *
   * @generated from field: bool include_unsafe = 4;
   */
  includeUnsafe: boolean;

  /**
   * Outouts to subtract the fee from, specified as as address from the
   * 'destinations' field. The fee will be equally deducted from the amount of
   * each specified output.
   *
   * @generated from field: repeated string subtract_fee_from_outputs = 5;
   */
  subtractFeeFromOutputs: string[];

  /**
   * When false, returns a serialized transaction which will not be added
   * to the wallet or broadcast.
   *
   * This is a 'bool value' instead of a plain bool. This is clunky to
   * work with, but the alternative would have been to either:
   *
   * 1. Have this be a bool with the default value as the opposite of
   *    Bitcoin Core
   * 2. Rename the parameter to something else.
   *
   * Both of these seem bad.
   *
   * @generated from field: google.protobuf.BoolValue add_to_wallet = 6;
   */
  addToWallet?: boolean;

  /**
   * Satoshis per virtual byte (sat/vB).
   *
   * @generated from field: double fee_rate = 7;
   */
  feeRate: number;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.SendRequest
 */
export declare type SendRequestJson = {
  /**
   * bitcoin address -> BTC amount
   *
   * @generated from field: map<string, double> destinations = 1;
   */
  destinations?: { [key: string]: number | "NaN" | "Infinity" | "-Infinity" };

  /**
   * Confirmation target in blocks.
   *
   * @generated from field: uint32 conf_target = 2;
   */
  confTarget?: number;

  /**
   * Only needs to be set if dealing with multiple wallets at the same time.
   * TODO: better suited as a header?
   *
   * @generated from field: string wallet = 3;
   */
  wallet?: string;

  /**
   * Include inputs that are not safe to spend (unconfirmed transactions from
   * outside keys and unconfirmed replacement transactions.
   *
   * @generated from field: bool include_unsafe = 4;
   */
  includeUnsafe?: boolean;

  /**
   * Outouts to subtract the fee from, specified as as address from the
   * 'destinations' field. The fee will be equally deducted from the amount of
   * each specified output.
   *
   * @generated from field: repeated string subtract_fee_from_outputs = 5;
   */
  subtractFeeFromOutputs?: string[];

  /**
   * When false, returns a serialized transaction which will not be added
   * to the wallet or broadcast.
   *
   * This is a 'bool value' instead of a plain bool. This is clunky to
   * work with, but the alternative would have been to either:
   *
   * 1. Have this be a bool with the default value as the opposite of
   *    Bitcoin Core
   * 2. Rename the parameter to something else.
   *
   * Both of these seem bad.
   *
   * @generated from field: google.protobuf.BoolValue add_to_wallet = 6;
   */
  addToWallet?: BoolValueJson;

  /**
   * Satoshis per virtual byte (sat/vB).
   *
   * @generated from field: double fee_rate = 7;
   */
  feeRate?: number | "NaN" | "Infinity" | "-Infinity";
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.SendRequest.
 * Use `create(SendRequestSchema)` to create a new message.
 */
export declare const SendRequestSchema: GenMessage<SendRequest, {jsonType: SendRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.SendResponse
 */
export declare type SendResponse = Message<"bitcoin.bitcoind.v1alpha.SendResponse"> & {
  /**
   * @generated from field: string txid = 1;
   */
  txid: string;

  /**
   * @generated from field: bool complete = 2;
   */
  complete: boolean;

  /**
   * If 'add_to_wallet' is false, the raw transaction with signature(s)
   *
   * @generated from field: bitcoin.bitcoind.v1alpha.RawTransaction tx = 3;
   */
  tx?: RawTransaction;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.SendResponse
 */
export declare type SendResponseJson = {
  /**
   * @generated from field: string txid = 1;
   */
  txid?: string;

  /**
   * @generated from field: bool complete = 2;
   */
  complete?: boolean;

  /**
   * If 'add_to_wallet' is false, the raw transaction with signature(s)
   *
   * @generated from field: bitcoin.bitcoind.v1alpha.RawTransaction tx = 3;
   */
  tx?: RawTransactionJson;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.SendResponse.
 * Use `create(SendResponseSchema)` to create a new message.
 */
export declare const SendResponseSchema: GenMessage<SendResponse, {jsonType: SendResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.SendToAddressRequest
 */
export declare type SendToAddressRequest = Message<"bitcoin.bitcoind.v1alpha.SendToAddressRequest"> & {
  /**
   * The bitcoin address to send to.
   *
   * @generated from field: string address = 1;
   */
  address: string;

  /**
   * The amount in BTC to send. eg 0.1
   *
   * @generated from field: double amount = 2;
   */
  amount: number;

  /**
   * A comment used to store what the transaction is for. Not part of the transaction, just kept in your wallet.
   *
   * @generated from field: string comment = 3;
   */
  comment: string;

  /**
   * A comment to store the name of the person or organization to which you're sending the transaction. Not part of the transaction, just kept in your wallet.
   *
   * @generated from field: string comment_to = 4;
   */
  commentTo: string;

  /**
   * Only needs to be set if dealing with multiple wallets at the same time.
   *
   * @generated from field: string wallet = 5;
   */
  wallet: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.SendToAddressRequest
 */
export declare type SendToAddressRequestJson = {
  /**
   * The bitcoin address to send to.
   *
   * @generated from field: string address = 1;
   */
  address?: string;

  /**
   * The amount in BTC to send. eg 0.1
   *
   * @generated from field: double amount = 2;
   */
  amount?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * A comment used to store what the transaction is for. Not part of the transaction, just kept in your wallet.
   *
   * @generated from field: string comment = 3;
   */
  comment?: string;

  /**
   * A comment to store the name of the person or organization to which you're sending the transaction. Not part of the transaction, just kept in your wallet.
   *
   * @generated from field: string comment_to = 4;
   */
  commentTo?: string;

  /**
   * Only needs to be set if dealing with multiple wallets at the same time.
   *
   * @generated from field: string wallet = 5;
   */
  wallet?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.SendToAddressRequest.
 * Use `create(SendToAddressRequestSchema)` to create a new message.
 */
export declare const SendToAddressRequestSchema: GenMessage<SendToAddressRequest, {jsonType: SendToAddressRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.SendToAddressResponse
 */
export declare type SendToAddressResponse = Message<"bitcoin.bitcoind.v1alpha.SendToAddressResponse"> & {
  /**
   * @generated from field: string txid = 1;
   */
  txid: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.SendToAddressResponse
 */
export declare type SendToAddressResponseJson = {
  /**
   * @generated from field: string txid = 1;
   */
  txid?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.SendToAddressResponse.
 * Use `create(SendToAddressResponseSchema)` to create a new message.
 */
export declare const SendToAddressResponseSchema: GenMessage<SendToAddressResponse, {jsonType: SendToAddressResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.EstimateSmartFeeRequest
 */
export declare type EstimateSmartFeeRequest = Message<"bitcoin.bitcoind.v1alpha.EstimateSmartFeeRequest"> & {
  /**
   * @generated from field: int64 conf_target = 1;
   */
  confTarget: bigint;

  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.EstimateSmartFeeRequest.EstimateMode estimate_mode = 2;
   */
  estimateMode: EstimateSmartFeeRequest_EstimateMode;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.EstimateSmartFeeRequest
 */
export declare type EstimateSmartFeeRequestJson = {
  /**
   * @generated from field: int64 conf_target = 1;
   */
  confTarget?: string;

  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.EstimateSmartFeeRequest.EstimateMode estimate_mode = 2;
   */
  estimateMode?: EstimateSmartFeeRequest_EstimateModeJson;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.EstimateSmartFeeRequest.
 * Use `create(EstimateSmartFeeRequestSchema)` to create a new message.
 */
export declare const EstimateSmartFeeRequestSchema: GenMessage<EstimateSmartFeeRequest, {jsonType: EstimateSmartFeeRequestJson}>;

/**
 * @generated from enum bitcoin.bitcoind.v1alpha.EstimateSmartFeeRequest.EstimateMode
 */
export enum EstimateSmartFeeRequest_EstimateMode {
  /**
   * @generated from enum value: ESTIMATE_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ESTIMATE_MODE_ECONOMICAL = 1;
   */
  ECONOMICAL = 1,

  /**
   * @generated from enum value: ESTIMATE_MODE_CONSERVATIVE = 2;
   */
  CONSERVATIVE = 2,
}

/**
 * @generated from enum bitcoin.bitcoind.v1alpha.EstimateSmartFeeRequest.EstimateMode
 */
export declare type EstimateSmartFeeRequest_EstimateModeJson = "ESTIMATE_MODE_UNSPECIFIED" | "ESTIMATE_MODE_ECONOMICAL" | "ESTIMATE_MODE_CONSERVATIVE";

/**
 * Describes the enum bitcoin.bitcoind.v1alpha.EstimateSmartFeeRequest.EstimateMode.
 */
export declare const EstimateSmartFeeRequest_EstimateModeSchema: GenEnum<EstimateSmartFeeRequest_EstimateMode, EstimateSmartFeeRequest_EstimateModeJson>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.EstimateSmartFeeResponse
 */
export declare type EstimateSmartFeeResponse = Message<"bitcoin.bitcoind.v1alpha.EstimateSmartFeeResponse"> & {
  /**
   * Estimate fee rate in BTC/kvB (only present if no errors were encountered)
   *
   * @generated from field: double fee_rate = 1;
   */
  feeRate: number;

  /**
   * Errors encountered during processing (if there are any)
   *
   * @generated from field: repeated string errors = 2;
   */
  errors: string[];

  /**
   * Block number where estimate was found.
   *
   * @generated from field: int64 blocks = 3;
   */
  blocks: bigint;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.EstimateSmartFeeResponse
 */
export declare type EstimateSmartFeeResponseJson = {
  /**
   * Estimate fee rate in BTC/kvB (only present if no errors were encountered)
   *
   * @generated from field: double fee_rate = 1;
   */
  feeRate?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * Errors encountered during processing (if there are any)
   *
   * @generated from field: repeated string errors = 2;
   */
  errors?: string[];

  /**
   * Block number where estimate was found.
   *
   * @generated from field: int64 blocks = 3;
   */
  blocks?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.EstimateSmartFeeResponse.
 * Use `create(EstimateSmartFeeResponseSchema)` to create a new message.
 */
export declare const EstimateSmartFeeResponseSchema: GenMessage<EstimateSmartFeeResponse, {jsonType: EstimateSmartFeeResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.DecodeRawTransactionRequest
 */
export declare type DecodeRawTransactionRequest = Message<"bitcoin.bitcoind.v1alpha.DecodeRawTransactionRequest"> & {
  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.RawTransaction tx = 1;
   */
  tx?: RawTransaction;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.DecodeRawTransactionRequest
 */
export declare type DecodeRawTransactionRequestJson = {
  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.RawTransaction tx = 1;
   */
  tx?: RawTransactionJson;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.DecodeRawTransactionRequest.
 * Use `create(DecodeRawTransactionRequestSchema)` to create a new message.
 */
export declare const DecodeRawTransactionRequestSchema: GenMessage<DecodeRawTransactionRequest, {jsonType: DecodeRawTransactionRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.RawTransaction
 */
export declare type RawTransaction = Message<"bitcoin.bitcoind.v1alpha.RawTransaction"> & {
  /**
   * Raw transaction data
   *
   * @generated from field: bytes data = 1;
   */
  data: Uint8Array;

  /**
   * Hex-encoded raw transaction data
   *
   * @generated from field: string hex = 2;
   */
  hex: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.RawTransaction
 */
export declare type RawTransactionJson = {
  /**
   * Raw transaction data
   *
   * @generated from field: bytes data = 1;
   */
  data?: string;

  /**
   * Hex-encoded raw transaction data
   *
   * @generated from field: string hex = 2;
   */
  hex?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.RawTransaction.
 * Use `create(RawTransactionSchema)` to create a new message.
 */
export declare const RawTransactionSchema: GenMessage<RawTransaction, {jsonType: RawTransactionJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.DecodeRawTransactionResponse
 */
export declare type DecodeRawTransactionResponse = Message<"bitcoin.bitcoind.v1alpha.DecodeRawTransactionResponse"> & {
  /**
   * @generated from field: string txid = 1;
   */
  txid: string;

  /**
   * @generated from field: string hash = 2;
   */
  hash: string;

  /**
   * The serialized transaction size
   *
   * @generated from field: uint32 size = 3;
   */
  size: number;

  /**
   * The virtual transaction size (differs from
   * 'size' for witness transactions).
   *
   * @generated from field: uint32 virtual_size = 4;
   */
  virtualSize: number;

  /**
   * The transaction's weight
   *
   * @generated from field: uint32 weight = 5;
   */
  weight: number;

  /**
   * @generated from field: uint32 version = 6;
   */
  version: number;

  /**
   * @generated from field: uint32 locktime = 7;
   */
  locktime: number;

  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.Input inputs = 8;
   */
  inputs: Input[];

  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.Output outputs = 9;
   */
  outputs: Output[];
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.DecodeRawTransactionResponse
 */
export declare type DecodeRawTransactionResponseJson = {
  /**
   * @generated from field: string txid = 1;
   */
  txid?: string;

  /**
   * @generated from field: string hash = 2;
   */
  hash?: string;

  /**
   * The serialized transaction size
   *
   * @generated from field: uint32 size = 3;
   */
  size?: number;

  /**
   * The virtual transaction size (differs from
   * 'size' for witness transactions).
   *
   * @generated from field: uint32 virtual_size = 4;
   */
  virtualSize?: number;

  /**
   * The transaction's weight
   *
   * @generated from field: uint32 weight = 5;
   */
  weight?: number;

  /**
   * @generated from field: uint32 version = 6;
   */
  version?: number;

  /**
   * @generated from field: uint32 locktime = 7;
   */
  locktime?: number;

  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.Input inputs = 8;
   */
  inputs?: InputJson[];

  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.Output outputs = 9;
   */
  outputs?: OutputJson[];
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.DecodeRawTransactionResponse.
 * Use `create(DecodeRawTransactionResponseSchema)` to create a new message.
 */
export declare const DecodeRawTransactionResponseSchema: GenMessage<DecodeRawTransactionResponse, {jsonType: DecodeRawTransactionResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ImportDescriptorsRequest
 */
export declare type ImportDescriptorsRequest = Message<"bitcoin.bitcoind.v1alpha.ImportDescriptorsRequest"> & {
  /**
   * Only needs to be set if dealing with multiple wallets at the same time.
   * TODO: better suited as a header?
   *
   * @generated from field: string wallet = 1;
   */
  wallet: string;

  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.ImportDescriptorsRequest.Request requests = 2;
   */
  requests: ImportDescriptorsRequest_Request[];
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ImportDescriptorsRequest
 */
export declare type ImportDescriptorsRequestJson = {
  /**
   * Only needs to be set if dealing with multiple wallets at the same time.
   * TODO: better suited as a header?
   *
   * @generated from field: string wallet = 1;
   */
  wallet?: string;

  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.ImportDescriptorsRequest.Request requests = 2;
   */
  requests?: ImportDescriptorsRequest_RequestJson[];
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.ImportDescriptorsRequest.
 * Use `create(ImportDescriptorsRequestSchema)` to create a new message.
 */
export declare const ImportDescriptorsRequestSchema: GenMessage<ImportDescriptorsRequest, {jsonType: ImportDescriptorsRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ImportDescriptorsRequest.Request
 */
export declare type ImportDescriptorsRequest_Request = Message<"bitcoin.bitcoind.v1alpha.ImportDescriptorsRequest.Request"> & {
  /**
   * Descriptor to import
   *
   * @generated from field: string descriptor = 1;
   */
  descriptor: string;

  /**
   * Set this descriptor to be the active descriptor for the corresponding type/externality.
   *
   * @generated from field: bool active = 2;
   */
  active: boolean;

  /**
   * @generated from field: uint32 range_start = 3;
   */
  rangeStart: number;

  /**
   * @generated from field: uint32 range_end = 4;
   */
  rangeEnd: number;

  /**
   * Nil passes 'now' to Bitcoin Core, which bypasses scanning.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 5;
   */
  timestamp?: Timestamp;

  /**
   * Whether matching outputs should be treated as not incoming payments (e.g. change)
   *
   * @generated from field: bool internal = 6;
   */
  internal: boolean;

  /**
   * Label to assign to the address, only allowed with internal = false. Disabled for ranged descriptors.
   *
   * @generated from field: string label = 7;
   */
  label: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ImportDescriptorsRequest.Request
 */
export declare type ImportDescriptorsRequest_RequestJson = {
  /**
   * Descriptor to import
   *
   * @generated from field: string descriptor = 1;
   */
  descriptor?: string;

  /**
   * Set this descriptor to be the active descriptor for the corresponding type/externality.
   *
   * @generated from field: bool active = 2;
   */
  active?: boolean;

  /**
   * @generated from field: uint32 range_start = 3;
   */
  rangeStart?: number;

  /**
   * @generated from field: uint32 range_end = 4;
   */
  rangeEnd?: number;

  /**
   * Nil passes 'now' to Bitcoin Core, which bypasses scanning.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 5;
   */
  timestamp?: TimestampJson;

  /**
   * Whether matching outputs should be treated as not incoming payments (e.g. change)
   *
   * @generated from field: bool internal = 6;
   */
  internal?: boolean;

  /**
   * Label to assign to the address, only allowed with internal = false. Disabled for ranged descriptors.
   *
   * @generated from field: string label = 7;
   */
  label?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.ImportDescriptorsRequest.Request.
 * Use `create(ImportDescriptorsRequest_RequestSchema)` to create a new message.
 */
export declare const ImportDescriptorsRequest_RequestSchema: GenMessage<ImportDescriptorsRequest_Request, {jsonType: ImportDescriptorsRequest_RequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse
 */
export declare type ImportDescriptorsResponse = Message<"bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse"> & {
  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse.Response responses = 1;
   */
  responses: ImportDescriptorsResponse_Response[];
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse
 */
export declare type ImportDescriptorsResponseJson = {
  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse.Response responses = 1;
   */
  responses?: ImportDescriptorsResponse_ResponseJson[];
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse.
 * Use `create(ImportDescriptorsResponseSchema)` to create a new message.
 */
export declare const ImportDescriptorsResponseSchema: GenMessage<ImportDescriptorsResponse, {jsonType: ImportDescriptorsResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse.Error
 */
export declare type ImportDescriptorsResponse_Error = Message<"bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse.Error"> & {
  /**
   * @generated from field: int32 code = 1;
   */
  code: number;

  /**
   * @generated from field: string message = 2;
   */
  message: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse.Error
 */
export declare type ImportDescriptorsResponse_ErrorJson = {
  /**
   * @generated from field: int32 code = 1;
   */
  code?: number;

  /**
   * @generated from field: string message = 2;
   */
  message?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse.Error.
 * Use `create(ImportDescriptorsResponse_ErrorSchema)` to create a new message.
 */
export declare const ImportDescriptorsResponse_ErrorSchema: GenMessage<ImportDescriptorsResponse_Error, {jsonType: ImportDescriptorsResponse_ErrorJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse.Response
 */
export declare type ImportDescriptorsResponse_Response = Message<"bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse.Response"> & {
  /**
   * @generated from field: bool success = 1;
   */
  success: boolean;

  /**
   * @generated from field: repeated string warnings = 2;
   */
  warnings: string[];

  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse.Error error = 3;
   */
  error?: ImportDescriptorsResponse_Error;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse.Response
 */
export declare type ImportDescriptorsResponse_ResponseJson = {
  /**
   * @generated from field: bool success = 1;
   */
  success?: boolean;

  /**
   * @generated from field: repeated string warnings = 2;
   */
  warnings?: string[];

  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse.Error error = 3;
   */
  error?: ImportDescriptorsResponse_ErrorJson;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.ImportDescriptorsResponse.Response.
 * Use `create(ImportDescriptorsResponse_ResponseSchema)` to create a new message.
 */
export declare const ImportDescriptorsResponse_ResponseSchema: GenMessage<ImportDescriptorsResponse_Response, {jsonType: ImportDescriptorsResponse_ResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetDescriptorInfoRequest
 */
export declare type GetDescriptorInfoRequest = Message<"bitcoin.bitcoind.v1alpha.GetDescriptorInfoRequest"> & {
  /**
   * @generated from field: string descriptor = 1;
   */
  descriptor: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetDescriptorInfoRequest
 */
export declare type GetDescriptorInfoRequestJson = {
  /**
   * @generated from field: string descriptor = 1;
   */
  descriptor?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetDescriptorInfoRequest.
 * Use `create(GetDescriptorInfoRequestSchema)` to create a new message.
 */
export declare const GetDescriptorInfoRequestSchema: GenMessage<GetDescriptorInfoRequest, {jsonType: GetDescriptorInfoRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetDescriptorInfoResponse
 */
export declare type GetDescriptorInfoResponse = Message<"bitcoin.bitcoind.v1alpha.GetDescriptorInfoResponse"> & {
  /**
   * The descriptor in canonical form, without private keys.
   *
   * @generated from field: string descriptor = 1;
   */
  descriptor: string;

  /**
   * The checksum for the input descriptor
   *
   * @generated from field: string checksum = 2;
   */
  checksum: string;

  /**
   * @generated from field: bool is_range = 3;
   */
  isRange: boolean;

  /**
   * @generated from field: bool is_solvable = 4;
   */
  isSolvable: boolean;

  /**
   * @generated from field: bool has_private_keys = 5;
   */
  hasPrivateKeys: boolean;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetDescriptorInfoResponse
 */
export declare type GetDescriptorInfoResponseJson = {
  /**
   * The descriptor in canonical form, without private keys.
   *
   * @generated from field: string descriptor = 1;
   */
  descriptor?: string;

  /**
   * The checksum for the input descriptor
   *
   * @generated from field: string checksum = 2;
   */
  checksum?: string;

  /**
   * @generated from field: bool is_range = 3;
   */
  isRange?: boolean;

  /**
   * @generated from field: bool is_solvable = 4;
   */
  isSolvable?: boolean;

  /**
   * @generated from field: bool has_private_keys = 5;
   */
  hasPrivateKeys?: boolean;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetDescriptorInfoResponse.
 * Use `create(GetDescriptorInfoResponseSchema)` to create a new message.
 */
export declare const GetDescriptorInfoResponseSchema: GenMessage<GetDescriptorInfoResponse, {jsonType: GetDescriptorInfoResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBlockRequest
 */
export declare type GetBlockRequest = Message<"bitcoin.bitcoind.v1alpha.GetBlockRequest"> & {
  /**
   * @generated from field: string hash = 1;
   */
  hash: string;

  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.GetBlockRequest.Verbosity verbosity = 2;
   */
  verbosity: GetBlockRequest_Verbosity;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBlockRequest
 */
export declare type GetBlockRequestJson = {
  /**
   * @generated from field: string hash = 1;
   */
  hash?: string;

  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.GetBlockRequest.Verbosity verbosity = 2;
   */
  verbosity?: GetBlockRequest_VerbosityJson;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetBlockRequest.
 * Use `create(GetBlockRequestSchema)` to create a new message.
 */
export declare const GetBlockRequestSchema: GenMessage<GetBlockRequest, {jsonType: GetBlockRequestJson}>;

/**
 * @generated from enum bitcoin.bitcoind.v1alpha.GetBlockRequest.Verbosity
 */
export enum GetBlockRequest_Verbosity {
  /**
   * @generated from enum value: VERBOSITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Returns the raw block data, completely unprocessed.
   *
   * @generated from enum value: VERBOSITY_RAW_DATA = 1;
   */
  RAW_DATA = 1,

  /**
   * Returns information about the block
   *
   * @generated from enum value: VERBOSITY_BLOCK_INFO = 2;
   */
  BLOCK_INFO = 2,

  /**
   * Returns information about the block and information
   * about each transaction
   *
   * @generated from enum value: VERBOSITY_BLOCK_TX_INFO = 3;
   */
  BLOCK_TX_INFO = 3,

  /**
   * Returns information about the block, information
   * about each transaction and prevout information.
   *
   * @generated from enum value: VERBOSITY_BLOCK_TX_PREVOUT_INFO = 4;
   */
  BLOCK_TX_PREVOUT_INFO = 4,
}

/**
 * @generated from enum bitcoin.bitcoind.v1alpha.GetBlockRequest.Verbosity
 */
export declare type GetBlockRequest_VerbosityJson = "VERBOSITY_UNSPECIFIED" | "VERBOSITY_RAW_DATA" | "VERBOSITY_BLOCK_INFO" | "VERBOSITY_BLOCK_TX_INFO" | "VERBOSITY_BLOCK_TX_PREVOUT_INFO";

/**
 * Describes the enum bitcoin.bitcoind.v1alpha.GetBlockRequest.Verbosity.
 */
export declare const GetBlockRequest_VerbositySchema: GenEnum<GetBlockRequest_Verbosity, GetBlockRequest_VerbosityJson>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBlockResponse
 */
export declare type GetBlockResponse = Message<"bitcoin.bitcoind.v1alpha.GetBlockResponse"> & {
  /**
   * @generated from field: string hex = 1;
   */
  hex: string;

  /**
   * @generated from field: string hash = 2;
   */
  hash: string;

  /**
   * @generated from field: int32 confirmations = 3;
   */
  confirmations: number;

  /**
   * @generated from field: uint32 height = 4;
   */
  height: number;

  /**
   * @generated from field: int32 version = 5;
   */
  version: number;

  /**
   * @generated from field: string version_hex = 6;
   */
  versionHex: string;

  /**
   * @generated from field: string merkle_root = 7;
   */
  merkleRoot: string;

  /**
   * google.protobuf.Timestamp median_time = 8; // not in rpcclient
   *
   * @generated from field: google.protobuf.Timestamp time = 8;
   */
  time?: Timestamp;

  /**
   * @generated from field: uint32 nonce = 9;
   */
  nonce: number;

  /**
   * @generated from field: string bits = 10;
   */
  bits: string;

  /**
   * @generated from field: double difficulty = 11;
   */
  difficulty: number;

  /**
   * Expected number of hashes required to produce the chain up to this block (in hex)
   * string chainwork = 12; // not in rpcclient
   *
   * @generated from field: string previous_block_hash = 12;
   */
  previousBlockHash: string;

  /**
   * @generated from field: string next_block_hash = 13;
   */
  nextBlockHash: string;

  /**
   * @generated from field: int32 stripped_size = 14;
   */
  strippedSize: number;

  /**
   * @generated from field: int32 size = 15;
   */
  size: number;

  /**
   * @generated from field: int32 weight = 16;
   */
  weight: number;

  /**
   * List of transactions in the block, by TXID.
   *
   * @generated from field: repeated string txids = 17;
   */
  txids: string[];
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBlockResponse
 */
export declare type GetBlockResponseJson = {
  /**
   * @generated from field: string hex = 1;
   */
  hex?: string;

  /**
   * @generated from field: string hash = 2;
   */
  hash?: string;

  /**
   * @generated from field: int32 confirmations = 3;
   */
  confirmations?: number;

  /**
   * @generated from field: uint32 height = 4;
   */
  height?: number;

  /**
   * @generated from field: int32 version = 5;
   */
  version?: number;

  /**
   * @generated from field: string version_hex = 6;
   */
  versionHex?: string;

  /**
   * @generated from field: string merkle_root = 7;
   */
  merkleRoot?: string;

  /**
   * google.protobuf.Timestamp median_time = 8; // not in rpcclient
   *
   * @generated from field: google.protobuf.Timestamp time = 8;
   */
  time?: TimestampJson;

  /**
   * @generated from field: uint32 nonce = 9;
   */
  nonce?: number;

  /**
   * @generated from field: string bits = 10;
   */
  bits?: string;

  /**
   * @generated from field: double difficulty = 11;
   */
  difficulty?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * Expected number of hashes required to produce the chain up to this block (in hex)
   * string chainwork = 12; // not in rpcclient
   *
   * @generated from field: string previous_block_hash = 12;
   */
  previousBlockHash?: string;

  /**
   * @generated from field: string next_block_hash = 13;
   */
  nextBlockHash?: string;

  /**
   * @generated from field: int32 stripped_size = 14;
   */
  strippedSize?: number;

  /**
   * @generated from field: int32 size = 15;
   */
  size?: number;

  /**
   * @generated from field: int32 weight = 16;
   */
  weight?: number;

  /**
   * List of transactions in the block, by TXID.
   *
   * @generated from field: repeated string txids = 17;
   */
  txids?: string[];
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetBlockResponse.
 * Use `create(GetBlockResponseSchema)` to create a new message.
 */
export declare const GetBlockResponseSchema: GenMessage<GetBlockResponse, {jsonType: GetBlockResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.BumpFeeRequest
 */
export declare type BumpFeeRequest = Message<"bitcoin.bitcoind.v1alpha.BumpFeeRequest"> & {
  /**
   * @generated from field: string wallet = 1;
   */
  wallet: string;

  /**
   * The TXID to be bumped
   *
   * @generated from field: string txid = 2;
   */
  txid: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.BumpFeeRequest
 */
export declare type BumpFeeRequestJson = {
  /**
   * @generated from field: string wallet = 1;
   */
  wallet?: string;

  /**
   * The TXID to be bumped
   *
   * @generated from field: string txid = 2;
   */
  txid?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.BumpFeeRequest.
 * Use `create(BumpFeeRequestSchema)` to create a new message.
 */
export declare const BumpFeeRequestSchema: GenMessage<BumpFeeRequest, {jsonType: BumpFeeRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.BumpFeeResponse
 */
export declare type BumpFeeResponse = Message<"bitcoin.bitcoind.v1alpha.BumpFeeResponse"> & {
  /**
   * @generated from field: string txid = 1;
   */
  txid: string;

  /**
   * @generated from field: double original_fee = 2;
   */
  originalFee: number;

  /**
   * @generated from field: double new_fee = 3;
   */
  newFee: number;

  /**
   * @generated from field: repeated string errors = 4;
   */
  errors: string[];
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.BumpFeeResponse
 */
export declare type BumpFeeResponseJson = {
  /**
   * @generated from field: string txid = 1;
   */
  txid?: string;

  /**
   * @generated from field: double original_fee = 2;
   */
  originalFee?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * @generated from field: double new_fee = 3;
   */
  newFee?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * @generated from field: repeated string errors = 4;
   */
  errors?: string[];
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.BumpFeeResponse.
 * Use `create(BumpFeeResponseSchema)` to create a new message.
 */
export declare const BumpFeeResponseSchema: GenMessage<BumpFeeResponse, {jsonType: BumpFeeResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ListSinceBlockRequest
 */
export declare type ListSinceBlockRequest = Message<"bitcoin.bitcoind.v1alpha.ListSinceBlockRequest"> & {
  /**
   * @generated from field: string wallet = 1;
   */
  wallet: string;

  /**
   * If set, the block hash to list transactions since, otherwise list all transactions.
   *
   * @generated from field: string hash = 2;
   */
  hash: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ListSinceBlockRequest
 */
export declare type ListSinceBlockRequestJson = {
  /**
   * @generated from field: string wallet = 1;
   */
  wallet?: string;

  /**
   * If set, the block hash to list transactions since, otherwise list all transactions.
   *
   * @generated from field: string hash = 2;
   */
  hash?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.ListSinceBlockRequest.
 * Use `create(ListSinceBlockRequestSchema)` to create a new message.
 */
export declare const ListSinceBlockRequestSchema: GenMessage<ListSinceBlockRequest, {jsonType: ListSinceBlockRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ListSinceBlockResponse
 */
export declare type ListSinceBlockResponse = Message<"bitcoin.bitcoind.v1alpha.ListSinceBlockResponse"> & {
  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.GetTransactionResponse transactions = 1;
   */
  transactions: GetTransactionResponse[];
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ListSinceBlockResponse
 */
export declare type ListSinceBlockResponseJson = {
  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.GetTransactionResponse transactions = 1;
   */
  transactions?: GetTransactionResponseJson[];
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.ListSinceBlockResponse.
 * Use `create(ListSinceBlockResponseSchema)` to create a new message.
 */
export declare const ListSinceBlockResponseSchema: GenMessage<ListSinceBlockResponse, {jsonType: ListSinceBlockResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetRawMempoolRequest
 */
export declare type GetRawMempoolRequest = Message<"bitcoin.bitcoind.v1alpha.GetRawMempoolRequest"> & {
  /**
   * @generated from field: bool verbose = 1;
   */
  verbose: boolean;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetRawMempoolRequest
 */
export declare type GetRawMempoolRequestJson = {
  /**
   * @generated from field: bool verbose = 1;
   */
  verbose?: boolean;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetRawMempoolRequest.
 * Use `create(GetRawMempoolRequestSchema)` to create a new message.
 */
export declare const GetRawMempoolRequestSchema: GenMessage<GetRawMempoolRequest, {jsonType: GetRawMempoolRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.MempoolEntry
 */
export declare type MempoolEntry = Message<"bitcoin.bitcoind.v1alpha.MempoolEntry"> & {
  /**
   * @generated from field: uint32 virtual_size = 1;
   */
  virtualSize: number;

  /**
   * @generated from field: uint32 weight = 2;
   */
  weight: number;

  /**
   * @generated from field: google.protobuf.Timestamp time = 3;
   */
  time?: Timestamp;

  /**
   * @generated from field: uint32 descendant_count = 4;
   */
  descendantCount: number;

  /**
   * @generated from field: uint32 descendant_size = 5;
   */
  descendantSize: number;

  /**
   * @generated from field: uint32 ancestor_count = 6;
   */
  ancestorCount: number;

  /**
   * @generated from field: uint32 ancestor_size = 7;
   */
  ancestorSize: number;

  /**
   * @generated from field: string witness_txid = 8;
   */
  witnessTxid: string;

  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.MempoolEntry.Fees fees = 9;
   */
  fees?: MempoolEntry_Fees;

  /**
   * @generated from field: repeated string depends = 10;
   */
  depends: string[];

  /**
   * @generated from field: repeated string spent_by = 11;
   */
  spentBy: string[];

  /**
   * @generated from field: bool bip125_replaceable = 12;
   */
  bip125Replaceable: boolean;

  /**
   * A transaction is unbroadcast if initial broadcast not yet
   * acknowledged by any peers.
   *
   * @generated from field: bool unbroadcast = 13;
   */
  unbroadcast: boolean;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.MempoolEntry
 */
export declare type MempoolEntryJson = {
  /**
   * @generated from field: uint32 virtual_size = 1;
   */
  virtualSize?: number;

  /**
   * @generated from field: uint32 weight = 2;
   */
  weight?: number;

  /**
   * @generated from field: google.protobuf.Timestamp time = 3;
   */
  time?: TimestampJson;

  /**
   * @generated from field: uint32 descendant_count = 4;
   */
  descendantCount?: number;

  /**
   * @generated from field: uint32 descendant_size = 5;
   */
  descendantSize?: number;

  /**
   * @generated from field: uint32 ancestor_count = 6;
   */
  ancestorCount?: number;

  /**
   * @generated from field: uint32 ancestor_size = 7;
   */
  ancestorSize?: number;

  /**
   * @generated from field: string witness_txid = 8;
   */
  witnessTxid?: string;

  /**
   * @generated from field: bitcoin.bitcoind.v1alpha.MempoolEntry.Fees fees = 9;
   */
  fees?: MempoolEntry_FeesJson;

  /**
   * @generated from field: repeated string depends = 10;
   */
  depends?: string[];

  /**
   * @generated from field: repeated string spent_by = 11;
   */
  spentBy?: string[];

  /**
   * @generated from field: bool bip125_replaceable = 12;
   */
  bip125Replaceable?: boolean;

  /**
   * A transaction is unbroadcast if initial broadcast not yet
   * acknowledged by any peers.
   *
   * @generated from field: bool unbroadcast = 13;
   */
  unbroadcast?: boolean;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.MempoolEntry.
 * Use `create(MempoolEntrySchema)` to create a new message.
 */
export declare const MempoolEntrySchema: GenMessage<MempoolEntry, {jsonType: MempoolEntryJson}>;

/**
 * All values are in whole bitcoins
 *
 * @generated from message bitcoin.bitcoind.v1alpha.MempoolEntry.Fees
 */
export declare type MempoolEntry_Fees = Message<"bitcoin.bitcoind.v1alpha.MempoolEntry.Fees"> & {
  /**
   * @generated from field: double base = 1;
   */
  base: number;

  /**
   * @generated from field: double modified = 2;
   */
  modified: number;

  /**
   * @generated from field: double ancestor = 3;
   */
  ancestor: number;

  /**
   * @generated from field: double descendant = 4;
   */
  descendant: number;
};

/**
 * All values are in whole bitcoins
 *
 * @generated from message bitcoin.bitcoind.v1alpha.MempoolEntry.Fees
 */
export declare type MempoolEntry_FeesJson = {
  /**
   * @generated from field: double base = 1;
   */
  base?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * @generated from field: double modified = 2;
   */
  modified?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * @generated from field: double ancestor = 3;
   */
  ancestor?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * @generated from field: double descendant = 4;
   */
  descendant?: number | "NaN" | "Infinity" | "-Infinity";
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.MempoolEntry.Fees.
 * Use `create(MempoolEntry_FeesSchema)` to create a new message.
 */
export declare const MempoolEntry_FeesSchema: GenMessage<MempoolEntry_Fees, {jsonType: MempoolEntry_FeesJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetRawMempoolResponse
 */
export declare type GetRawMempoolResponse = Message<"bitcoin.bitcoind.v1alpha.GetRawMempoolResponse"> & {
  /**
   * Only set if this is a non-verbose response
   *
   * @generated from field: repeated string txids = 1;
   */
  txids: string[];

  /**
   * Only set if this is a verbose response
   *
   * @generated from field: map<string, bitcoin.bitcoind.v1alpha.MempoolEntry> transactions = 2;
   */
  transactions: { [key: string]: MempoolEntry };
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetRawMempoolResponse
 */
export declare type GetRawMempoolResponseJson = {
  /**
   * Only set if this is a non-verbose response
   *
   * @generated from field: repeated string txids = 1;
   */
  txids?: string[];

  /**
   * Only set if this is a verbose response
   *
   * @generated from field: map<string, bitcoin.bitcoind.v1alpha.MempoolEntry> transactions = 2;
   */
  transactions?: { [key: string]: MempoolEntryJson };
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetRawMempoolResponse.
 * Use `create(GetRawMempoolResponseSchema)` to create a new message.
 */
export declare const GetRawMempoolResponseSchema: GenMessage<GetRawMempoolResponse, {jsonType: GetRawMempoolResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBlockHashRequest
 */
export declare type GetBlockHashRequest = Message<"bitcoin.bitcoind.v1alpha.GetBlockHashRequest"> & {
  /**
   * @generated from field: uint32 height = 1;
   */
  height: number;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBlockHashRequest
 */
export declare type GetBlockHashRequestJson = {
  /**
   * @generated from field: uint32 height = 1;
   */
  height?: number;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetBlockHashRequest.
 * Use `create(GetBlockHashRequestSchema)` to create a new message.
 */
export declare const GetBlockHashRequestSchema: GenMessage<GetBlockHashRequest, {jsonType: GetBlockHashRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBlockHashResponse
 */
export declare type GetBlockHashResponse = Message<"bitcoin.bitcoind.v1alpha.GetBlockHashResponse"> & {
  /**
   * @generated from field: string hash = 1;
   */
  hash: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetBlockHashResponse
 */
export declare type GetBlockHashResponseJson = {
  /**
   * @generated from field: string hash = 1;
   */
  hash?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetBlockHashResponse.
 * Use `create(GetBlockHashResponseSchema)` to create a new message.
 */
export declare const GetBlockHashResponseSchema: GenMessage<GetBlockHashResponse, {jsonType: GetBlockHashResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ListTransactionsRequest
 */
export declare type ListTransactionsRequest = Message<"bitcoin.bitcoind.v1alpha.ListTransactionsRequest"> & {
  /**
   * @generated from field: string wallet = 1;
   */
  wallet: string;

  /**
   * Defaults to 10
   *
   * @generated from field: uint32 count = 2;
   */
  count: number;

  /**
   * @generated from field: uint32 skip = 3;
   */
  skip: number;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ListTransactionsRequest
 */
export declare type ListTransactionsRequestJson = {
  /**
   * @generated from field: string wallet = 1;
   */
  wallet?: string;

  /**
   * Defaults to 10
   *
   * @generated from field: uint32 count = 2;
   */
  count?: number;

  /**
   * @generated from field: uint32 skip = 3;
   */
  skip?: number;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.ListTransactionsRequest.
 * Use `create(ListTransactionsRequestSchema)` to create a new message.
 */
export declare const ListTransactionsRequestSchema: GenMessage<ListTransactionsRequest, {jsonType: ListTransactionsRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ListTransactionsResponse
 */
export declare type ListTransactionsResponse = Message<"bitcoin.bitcoind.v1alpha.ListTransactionsResponse"> & {
  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.GetTransactionResponse transactions = 1;
   */
  transactions: GetTransactionResponse[];
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ListTransactionsResponse
 */
export declare type ListTransactionsResponseJson = {
  /**
   * @generated from field: repeated bitcoin.bitcoind.v1alpha.GetTransactionResponse transactions = 1;
   */
  transactions?: GetTransactionResponseJson[];
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.ListTransactionsResponse.
 * Use `create(ListTransactionsResponseSchema)` to create a new message.
 */
export declare const ListTransactionsResponseSchema: GenMessage<ListTransactionsResponse, {jsonType: ListTransactionsResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ListWalletsResponse
 */
export declare type ListWalletsResponse = Message<"bitcoin.bitcoind.v1alpha.ListWalletsResponse"> & {
  /**
   * @generated from field: repeated string wallets = 1;
   */
  wallets: string[];
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.ListWalletsResponse
 */
export declare type ListWalletsResponseJson = {
  /**
   * @generated from field: repeated string wallets = 1;
   */
  wallets?: string[];
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.ListWalletsResponse.
 * Use `create(ListWalletsResponseSchema)` to create a new message.
 */
export declare const ListWalletsResponseSchema: GenMessage<ListWalletsResponse, {jsonType: ListWalletsResponseJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetAddressInfoRequest
 */
export declare type GetAddressInfoRequest = Message<"bitcoin.bitcoind.v1alpha.GetAddressInfoRequest"> & {
  /**
   * @generated from field: string address = 1;
   */
  address: string;

  /**
   * @generated from field: string wallet = 2;
   */
  wallet: string;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetAddressInfoRequest
 */
export declare type GetAddressInfoRequestJson = {
  /**
   * @generated from field: string address = 1;
   */
  address?: string;

  /**
   * @generated from field: string wallet = 2;
   */
  wallet?: string;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetAddressInfoRequest.
 * Use `create(GetAddressInfoRequestSchema)` to create a new message.
 */
export declare const GetAddressInfoRequestSchema: GenMessage<GetAddressInfoRequest, {jsonType: GetAddressInfoRequestJson}>;

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetAddressInfoResponse
 */
export declare type GetAddressInfoResponse = Message<"bitcoin.bitcoind.v1alpha.GetAddressInfoResponse"> & {
  /**
   * @generated from field: string address = 1;
   */
  address: string;

  /**
   * Hex-encoded script pub key
   *
   * @generated from field: string script_pub_key = 2;
   */
  scriptPubKey: string;

  /**
   * @generated from field: bool is_mine = 3;
   */
  isMine: boolean;

  /**
   * @generated from field: bool is_watch_only = 4;
   */
  isWatchOnly: boolean;

  /**
   * If Core knows how to spend coins sent to this address, ignoring
   * possible lack of private keys.
   *
   * @generated from field: bool solvable = 5;
   */
  solvable: boolean;

  /**
   * @generated from field: bool is_script = 6;
   */
  isScript: boolean;

  /**
   * @generated from field: bool is_change = 7;
   */
  isChange: boolean;

  /**
   * @generated from field: bool is_witness = 8;
   */
  isWitness: boolean;

  /**
   * @generated from field: uint32 witness_version = 9;
   */
  witnessVersion: number;

  /**
   * Hex-encoded
   *
   * @generated from field: string witness_program = 10;
   */
  witnessProgram: string;

  /**
   * @generated from field: string script_type = 11;
   */
  scriptType: string;

  /**
   * @generated from field: bool is_compressed = 12;
   */
  isCompressed: boolean;
};

/**
 * @generated from message bitcoin.bitcoind.v1alpha.GetAddressInfoResponse
 */
export declare type GetAddressInfoResponseJson = {
  /**
   * @generated from field: string address = 1;
   */
  address?: string;

  /**
   * Hex-encoded script pub key
   *
   * @generated from field: string script_pub_key = 2;
   */
  scriptPubKey?: string;

  /**
   * @generated from field: bool is_mine = 3;
   */
  isMine?: boolean;

  /**
   * @generated from field: bool is_watch_only = 4;
   */
  isWatchOnly?: boolean;

  /**
   * If Core knows how to spend coins sent to this address, ignoring
   * possible lack of private keys.
   *
   * @generated from field: bool solvable = 5;
   */
  solvable?: boolean;

  /**
   * @generated from field: bool is_script = 6;
   */
  isScript?: boolean;

  /**
   * @generated from field: bool is_change = 7;
   */
  isChange?: boolean;

  /**
   * @generated from field: bool is_witness = 8;
   */
  isWitness?: boolean;

  /**
   * @generated from field: uint32 witness_version = 9;
   */
  witnessVersion?: number;

  /**
   * Hex-encoded
   *
   * @generated from field: string witness_program = 10;
   */
  witnessProgram?: string;

  /**
   * @generated from field: string script_type = 11;
   */
  scriptType?: string;

  /**
   * @generated from field: bool is_compressed = 12;
   */
  isCompressed?: boolean;
};

/**
 * Describes the message bitcoin.bitcoind.v1alpha.GetAddressInfoResponse.
 * Use `create(GetAddressInfoResponseSchema)` to create a new message.
 */
export declare const GetAddressInfoResponseSchema: GenMessage<GetAddressInfoResponse, {jsonType: GetAddressInfoResponseJson}>;

/**
 * @generated from service bitcoin.bitcoind.v1alpha.BitcoinService
 */
export declare const BitcoinService: GenService<{
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.GetBlockchainInfo
   */
  getBlockchainInfo: {
    methodKind: "unary";
    input: typeof GetBlockchainInfoRequestSchema;
    output: typeof GetBlockchainInfoResponseSchema;
  },
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.GetPeerInfo
   */
  getPeerInfo: {
    methodKind: "unary";
    input: typeof GetPeerInfoRequestSchema;
    output: typeof GetPeerInfoResponseSchema;
  },
  /**
   * Fetches in-wallet transactions
   *
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.GetTransaction
   */
  getTransaction: {
    methodKind: "unary";
    input: typeof GetTransactionRequestSchema;
    output: typeof GetTransactionResponseSchema;
  },
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.ListSinceBlock
   */
  listSinceBlock: {
    methodKind: "unary";
    input: typeof ListSinceBlockRequestSchema;
    output: typeof ListSinceBlockResponseSchema;
  },
  /**
   * Wallet stuff
   *
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.GetNewAddress
   */
  getNewAddress: {
    methodKind: "unary";
    input: typeof GetNewAddressRequestSchema;
    output: typeof GetNewAddressResponseSchema;
  },
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.GetWalletInfo
   */
  getWalletInfo: {
    methodKind: "unary";
    input: typeof GetWalletInfoRequestSchema;
    output: typeof GetWalletInfoResponseSchema;
  },
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.GetBalances
   */
  getBalances: {
    methodKind: "unary";
    input: typeof GetBalancesRequestSchema;
    output: typeof GetBalancesResponseSchema;
  },
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.Send
   */
  send: {
    methodKind: "unary";
    input: typeof SendRequestSchema;
    output: typeof SendResponseSchema;
  },
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.SendToAddress
   */
  sendToAddress: {
    methodKind: "unary";
    input: typeof SendToAddressRequestSchema;
    output: typeof SendToAddressResponseSchema;
  },
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.BumpFee
   */
  bumpFee: {
    methodKind: "unary";
    input: typeof BumpFeeRequestSchema;
    output: typeof BumpFeeResponseSchema;
  },
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.EstimateSmartFee
   */
  estimateSmartFee: {
    methodKind: "unary";
    input: typeof EstimateSmartFeeRequestSchema;
    output: typeof EstimateSmartFeeResponseSchema;
  },
  /**
   * Import a descriptor. If importing a watch-only descriptor, the wallet itself needs
   * to be watch-only as well. The descriptor also needs to be normalized, with a
   * checksum. This can be obtained by running it through GetDescriptorInfo.
   *
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.ImportDescriptors
   */
  importDescriptors: {
    methodKind: "unary";
    input: typeof ImportDescriptorsRequestSchema;
    output: typeof ImportDescriptorsResponseSchema;
  },
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.ListWallets
   */
  listWallets: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof ListWalletsResponseSchema;
  },
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.ListTransactions
   */
  listTransactions: {
    methodKind: "unary";
    input: typeof ListTransactionsRequestSchema;
    output: typeof ListTransactionsResponseSchema;
  },
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.GetDescriptorInfo
   */
  getDescriptorInfo: {
    methodKind: "unary";
    input: typeof GetDescriptorInfoRequestSchema;
    output: typeof GetDescriptorInfoResponseSchema;
  },
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.GetAddressInfo
   */
  getAddressInfo: {
    methodKind: "unary";
    input: typeof GetAddressInfoRequestSchema;
    output: typeof GetAddressInfoResponseSchema;
  },
  /**
   * Mempool stuff
   *
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.GetRawMempool
   */
  getRawMempool: {
    methodKind: "unary";
    input: typeof GetRawMempoolRequestSchema;
    output: typeof GetRawMempoolResponseSchema;
  },
  /**
   * Raw TX stuff
   *
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.GetRawTransaction
   */
  getRawTransaction: {
    methodKind: "unary";
    input: typeof GetRawTransactionRequestSchema;
    output: typeof GetRawTransactionResponseSchema;
  },
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.DecodeRawTransaction
   */
  decodeRawTransaction: {
    methodKind: "unary";
    input: typeof DecodeRawTransactionRequestSchema;
    output: typeof DecodeRawTransactionResponseSchema;
  },
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.GetBlock
   */
  getBlock: {
    methodKind: "unary";
    input: typeof GetBlockRequestSchema;
    output: typeof GetBlockResponseSchema;
  },
  /**
   * @generated from rpc bitcoin.bitcoind.v1alpha.BitcoinService.GetBlockHash
   */
  getBlockHash: {
    methodKind: "unary";
    input: typeof GetBlockHashRequestSchema;
    output: typeof GetBlockHashResponseSchema;
  },
}>;

