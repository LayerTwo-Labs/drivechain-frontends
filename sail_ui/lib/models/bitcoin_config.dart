class BitcoinConfig {
  Map<String, String> globalSettings = {};
  Map<String, Map<String, String>> networkSettings = {
    'main': {},
    'test': {},
    'signet': {},
    'regtest': {},
  };

  BitcoinConfig();

  BitcoinConfig.fromConfig(BitcoinConfig other) {
    globalSettings = Map<String, String>.from(other.globalSettings);
    for (final network in networkSettings.keys) {
      networkSettings[network] = Map<String, String>.from(other.networkSettings[network]!);
    }
  }

  static BitcoinConfig parse(String content) {
    final config = BitcoinConfig();
    String? currentSection;
    final lines = content.split('\n');

    for (final line in lines) {
      final trimmed = line.trim();

      // Skip empty lines and comments
      if (trimmed.isEmpty || trimmed.startsWith('#')) {
        continue;
      }

      // Check for section header
      if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
        final section = trimmed.substring(1, trimmed.length - 1);
        if (config.networkSettings.containsKey(section)) {
          currentSection = section;
        }
        continue;
      }

      // Parse key=value pairs
      final parts = trimmed.split('=');
      if (parts.length >= 2) {
        final key = parts[0].trim();
        final value = parts.sublist(1).join('=').trim();

        if (currentSection != null) {
          config.networkSettings[currentSection]![key] = value;
        } else {
          config.globalSettings[key] = value;
        }
      }
    }

    return config;
  }

  String serialize() {
    final buffer = StringBuffer();

    // Add header comment
    buffer.writeln('# Generated by BitWindow Bitcoin Configuration Editor');
    buffer.writeln();

    // Write global settings
    if (globalSettings.isNotEmpty) {
      buffer.writeln('# [core]');
      for (final entry in globalSettings.entries) {
        buffer.writeln('${entry.key}=${entry.value}');
      }
      buffer.writeln();
    }

    // Write network-specific settings
    final sectionNames = {
      'main': '[main]',
      'test': '[test]',
      'signet': '[signet]',
      'regtest': '[regtest]',
    };


    for (final network in networkSettings.keys) {
      final settings = networkSettings[network]!;
      if (settings.isNotEmpty) {
        buffer.writeln('# Options for ${network == 'main' ? 'mainnet' : network} only');
        buffer.writeln(sectionNames[network]);
        for (final entry in settings.entries) {
          buffer.writeln('${entry.key}=${entry.value}');
        }
        buffer.writeln();
      }
    }

    return buffer.toString();
  }

  void setSetting(String key, String value, {String? section}) {
    if (section != null && networkSettings.containsKey(section)) {
      networkSettings[section]![key] = value;
    } else {
      globalSettings[key] = value;
    }
  }

  void removeSetting(String key, {String? section}) {
    if (section != null && networkSettings.containsKey(section)) {
      networkSettings[section]!.remove(key);
    } else {
      globalSettings.remove(key);
    }
  }

  String? getSetting(String key, {String? section}) {
    if (section != null && networkSettings.containsKey(section)) {
      return networkSettings[section]![key];
    }
    return globalSettings[key];
  }

  bool hasSetting(String key, {String? section}) {
    if (section != null && networkSettings.containsKey(section)) {
      return networkSettings[section]!.containsKey(key);
    }
    return globalSettings.containsKey(key);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! BitcoinConfig) return false;

    // Check global settings equality
    if (globalSettings.length != other.globalSettings.length) return false;
    for (final key in globalSettings.keys) {
      if (globalSettings[key] != other.globalSettings[key]) return false;
    }

    // Check network settings equality
    for (final network in networkSettings.keys) {
      final thisNetwork = networkSettings[network]!;
      final otherNetwork = other.networkSettings[network]!;
      if (thisNetwork.length != otherNetwork.length) return false;
      for (final key in thisNetwork.keys) {
        if (thisNetwork[key] != otherNetwork[key]) return false;
      }
    }

    return true;
  }

  @override
  int get hashCode {
    int result = globalSettings.hashCode;
    for (final network in networkSettings.keys) {
      result = result ^ networkSettings[network].hashCode;
    }
    return result;
  }
}

enum ConfigPreset {
  defaultPreset,
  performance,
  storageOptimized,
  custom,
}

class ConfigPresets {
  static Map<String, String> getPresetSettings(ConfigPreset preset) {
    switch (preset) {
      case ConfigPreset.defaultPreset:
        return {
          'rpcuser': 'user',
          'rpcpassword': 'password',
          'server': '1',
          'listen': '1',
          'txindex': '1',
          'rpcthreads': '20',
          'rpcworkqueue': '100',
          'rest': '1',
          'fallbackfee': '0.00021',
        };

      case ConfigPreset.performance:
        return {
          'rpcuser': 'user',
          'rpcpassword': 'password',
          'server': '1',
          'listen': '1',
          'txindex': '1',
          'dbcache': '4000',
          'maxorphantx': '1000',
          'maxmempool': '1000',
          'blockreconstructionextratxn': '1000',
          'maxsigcachesize': '100',
          'blockmaxweight': '4000000',
          'rpcthreads': '20',
          'rpcworkqueue': '100',
          'rest': '1',
          'fallbackfee': '0.00021',
        };

      case ConfigPreset.storageOptimized:
        return {
          'rpcuser': 'user',
          'rpcpassword': 'password',
          'server': '1',
          'listen': '1',
          'prune': '550',
          'dbcache': '450',
          'maxmempool': '300',
          'rpcthreads': '20',
          'rpcworkqueue': '100',
          'rest': '1',
          'fallbackfee': '0.00021',
        };

      case ConfigPreset.custom:
        return {};
    }
  }

  static String getPresetName(ConfigPreset preset) {
    switch (preset) {
      case ConfigPreset.defaultPreset:
        return 'Default';
      case ConfigPreset.performance:
        return 'Performance';
      case ConfigPreset.storageOptimized:
        return 'Storage Optimized';
      case ConfigPreset.custom:
        return 'Custom';
    }
  }
}
