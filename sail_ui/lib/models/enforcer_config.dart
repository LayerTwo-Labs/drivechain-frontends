/// Comment line prefix for stored config version. Used by migration system.
const String kEnforcerConfVersionCommentPrefix = '# bitwindow-enforcer-conf-version=';

/// Configuration model for the Enforcer daemon.
/// Unlike Bitcoin Core, the Enforcer doesn't read from a conf file directly -
/// it only accepts CLI arguments. We store settings in a file and convert them
/// to CLI args at launch time.
class EnforcerConfig {
  Map<String, String> settings = {};

  /// Stored config version for migrations. 0 = legacy (no version line).
  int configVersion = 0;

  EnforcerConfig();

  EnforcerConfig.fromConfig(EnforcerConfig other) {
    settings = Map<String, String>.from(other.settings);
    configVersion = other.configVersion;
  }

  /// Parse a simple key=value format config file (no sections)
  static EnforcerConfig parse(String content) {
    final config = EnforcerConfig();
    final lines = content.split('\n');

    for (final line in lines) {
      final trimmed = line.trim();

      // Parse version comment for migration system
      if (trimmed.startsWith(kEnforcerConfVersionCommentPrefix)) {
        final v = int.tryParse(trimmed.substring(kEnforcerConfVersionCommentPrefix.length).trim());
        if (v != null && v >= 0) config.configVersion = v;
        continue;
      }

      // Skip empty lines and other comments
      if (trimmed.isEmpty || trimmed.startsWith('#')) {
        continue;
      }

      // Parse key=value pairs
      final equals = trimmed.indexOf('=');
      if (equals > 0) {
        final key = trimmed.substring(0, equals).trim();
        final value = trimmed.substring(equals + 1).trim();
        config.settings[key] = value;
      }
    }

    return config;
  }

  String serialize() {
    final buffer = StringBuffer();

    if (configVersion > 0) {
      buffer.writeln('$kEnforcerConfVersionCommentPrefix$configVersion');
      buffer.writeln();
    }
    // Add header comment
    buffer.writeln('# Enforcer Configuration - Generated by BitWindow');
    buffer.writeln('# These settings are converted to CLI arguments when the Enforcer starts.');
    buffer.writeln();

    // Write settings
    for (final entry in settings.entries) {
      buffer.writeln('${entry.key}=${entry.value}');
    }

    return buffer.toString();
  }

  void setSetting(String key, String value) {
    settings[key] = value;
  }

  void removeSetting(String key) {
    settings.remove(key);
  }

  String? getSetting(String key) {
    return settings[key];
  }

  bool hasSetting(String key) {
    return settings.containsKey(key);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! EnforcerConfig) return false;

    if (configVersion != other.configVersion) return false;
    if (settings.length != other.settings.length) return false;
    for (final key in settings.keys) {
      if (settings[key] != other.settings[key]) return false;
    }

    return true;
  }

  @override
  int get hashCode {
    return Object.hash(configVersion, settings.hashCode);
  }
}

enum EnforcerConfigPreset {
  defaultPreset,
  minimal,
  custom,
}

class EnforcerConfigPresets {
  static Map<String, String> getPresetSettings(EnforcerConfigPreset preset) {
    switch (preset) {
      case EnforcerConfigPreset.defaultPreset:
        return {
          'enable-wallet': 'true',
          'enable-mempool': 'true',
        };

      case EnforcerConfigPreset.minimal:
        return {
          'enable-wallet': 'true',
          'enable-mempool': 'false',
        };

      case EnforcerConfigPreset.custom:
        return {};
    }
  }

  static String getPresetName(EnforcerConfigPreset preset) {
    switch (preset) {
      case EnforcerConfigPreset.defaultPreset:
        return 'Default';
      case EnforcerConfigPreset.minimal:
        return 'Minimal';
      case EnforcerConfigPreset.custom:
        return 'Custom';
    }
  }
}
