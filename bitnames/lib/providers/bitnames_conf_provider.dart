import 'dart:async';
import 'dart:io' show Directory, File, FileSystemEvent;

import 'package:flutter/foundation.dart';
import 'package:get_it/get_it.dart';
import 'package:logger/logger.dart';
import 'package:path/path.dart' as path;
import 'package:sail_ui/sail_ui.dart';

import 'package:bitnames/models/bitnames_config.dart';

/// Provider for BitNames configuration settings.
/// BitNames doesn't read from a conf file directly - it only accepts CLI arguments.
/// We store settings in a file and convert them to CLI args at launch time.
class BitnamesConfProvider extends ChangeNotifier {
  final Logger log = GetIt.I.get<Logger>();

  StreamSubscription<FileSystemEvent>? _fileWatcher;
  Timer? _fileWatchDebouncer;

  BitnamesConfig? currentConfig;
  String? configPath;

  BitnamesConfProvider._create();

  static Future<BitnamesConfProvider> create() async {
    final instance = BitnamesConfProvider._create();
    await instance.loadConfig();
    instance._setupFileWatching();
    instance._listenToBitcoinConf();
    await instance.syncNetworkFromBitcoinConf();
    return instance;
  }

  void _listenToBitcoinConf() {
    GetIt.I.get<BitcoinConfProvider>().addListener(_onBitcoinConfChanged);
  }

  void _onBitcoinConfChanged() {
    syncNetworkFromBitcoinConf();
  }

  Future<void> _saveConfig() async {
    if (currentConfig == null) return;
    try {
      final confPath = _getConfigPath();
      final file = File(confPath);
      await file.parent.create(recursive: true);
      await file.writeAsString(currentConfig!.serialize());
      log.i('Saved BitNames config to $confPath');
    } catch (e) {
      log.e('Failed to save BitNames config: $e');
    }
  }

  /// Sync network setting from BitcoinConfProvider
  Future<void> syncNetworkFromBitcoinConf() async {
    if (currentConfig == null) return;

    final bitcoinConfProvider = GetIt.I.get<BitcoinConfProvider>();
    final network = bitcoinConfProvider.network;

    // BitNames only supports signet and regtest
    final bitnamesNetwork = switch (network) {
      BitcoinNetwork.BITCOIN_NETWORK_SIGNET => 'signet',
      BitcoinNetwork.BITCOIN_NETWORK_REGTEST => 'regtest',
      _ => 'signet', // fallback for unsupported networks
    };

    final currentNetwork = currentConfig!.getSetting('network');
    if (currentNetwork != bitnamesNetwork) {
      currentConfig!.setSetting('network', bitnamesNetwork);

      // Update network-specific ports
      final ports = _getNetworkPorts(bitnamesNetwork);
      currentConfig!.setSetting('rpc-addr', ports['rpc-addr']!);
      currentConfig!.setSetting('net-addr', ports['net-addr']!);
      currentConfig!.setSetting('zmq-addr', ports['zmq-addr']!);
      currentConfig!.setSetting('mainchain-grpc-port', ports['mainchain-grpc-port']!);

      notifyListeners();
      await _saveConfig();
    }
  }

  @override
  void dispose() {
    _fileWatcher?.cancel();
    _fileWatchDebouncer?.cancel();
    try {
      GetIt.I.get<BitcoinConfProvider>().removeListener(_onBitcoinConfChanged);
    } catch (_) {}
    super.dispose();
  }

  /// Get the path to the BitNames config file
  String _getConfigPath() {
    final datadir = BitNames().datadir();
    return path.join(datadir, 'bitnames.conf');
  }

  /// Load config from file, or create default if not exists
  Future<void> loadConfig() async {
    try {
      configPath = _getConfigPath();
      final file = File(configPath!);

      String content = '';
      if (await file.exists()) {
        content = await file.readAsString();
      } else {
        content = getDefaultConfig();

        try {
          await file.parent.create(recursive: true);
          await file.writeAsString(content);
          log.i('Created default BitNames config file: ${file.path}');
        } catch (e) {
          log.e('Failed to write default BitNames config file: $e');
        }
      }

      currentConfig = BitnamesConfig.parse(content);
    } catch (e) {
      log.e('Failed to load BitNames config: $e');
    } finally {
      notifyListeners();
    }
  }

  /// Get the default configuration content
  String getDefaultConfig() {
    // Get current network from BitcoinConfProvider if available
    String network = 'signet';
    try {
      final bitcoinConfProvider = GetIt.I.get<BitcoinConfProvider>();
      network = switch (bitcoinConfProvider.network) {
        BitcoinNetwork.BITCOIN_NETWORK_SIGNET => 'signet',
        BitcoinNetwork.BITCOIN_NETWORK_REGTEST => 'regtest',
        _ => 'signet',
      };
    } catch (_) {}

    // Network-specific ports
    final ports = _getNetworkPorts(network);

    return '''# BitNames Configuration - Generated by BitNames App
# These settings are converted to CLI arguments when BitNames starts.

# Run in headless mode (no GUI)
headless=true

# Log level for console output
log-level=DEBUG

# Network (signet or regtest)
network=$network

# RPC server address
rpc-addr=${ports['rpc-addr']}

# P2P networking address
net-addr=${ports['net-addr']}

# ZMQ pub/sub address
zmq-addr=${ports['zmq-addr']}

# Mainchain (Enforcer) gRPC connection
mainchain-grpc-host=127.0.0.1
mainchain-grpc-port=${ports['mainchain-grpc-port']}
''';
  }

  /// Get network-specific ports for BitNames
  Map<String, String> _getNetworkPorts(String network) {
    switch (network) {
      case 'regtest':
        return {
          'rpc-addr': '127.0.0.1:16002',
          'net-addr': '0.0.0.0:14002',
          'zmq-addr': '127.0.0.1:38002',
          'mainchain-grpc-port': '50051',
        };
      case 'signet':
      default:
        return {
          'rpc-addr': '127.0.0.1:6002',
          'net-addr': '0.0.0.0:4002',
          'zmq-addr': '127.0.0.1:28002',
          'mainchain-grpc-port': '50051',
        };
    }
  }

  /// Get the current configuration content as string
  String getCurrentConfigContent() {
    if (currentConfig == null) {
      return getDefaultConfig();
    }
    return currentConfig!.serialize();
  }

  /// Write configuration content to the file
  Future<void> writeConfig(String content) async {
    try {
      final config = BitnamesConfig.parse(content);
      currentConfig = config;

      final confPath = _getConfigPath();
      final file = File(confPath);
      await file.parent.create(recursive: true);
      await file.writeAsString(content);

      log.i('Saved BitNames config to $confPath');
      notifyListeners();
    } catch (e) {
      log.e('Failed to write BitNames config: $e');
      rethrow;
    }
  }

  /// Convert current config to CLI args for BitNames
  List<String> getCliArgs() {
    final args = <String>[];

    if (currentConfig == null) return args;

    for (final entry in currentConfig!.settings.entries) {
      final key = entry.key;
      final value = entry.value;

      if (value == 'true') {
        args.add('--$key');
      } else if (value == 'false') {
        continue;
      } else if (value.isNotEmpty) {
        args.add('--$key=$value');
      }
    }

    return args;
  }

  void _setupFileWatching() {
    _fileWatcher?.cancel();

    try {
      final confPath = _getConfigPath();
      final confDir = Directory(path.dirname(confPath));

      if (!confDir.existsSync()) {
        confDir.createSync(recursive: true);
      }

      _fileWatcher = confDir
          .watch(events: FileSystemEvent.modify | FileSystemEvent.create | FileSystemEvent.delete)
          .where((event) => event.path.endsWith('bitnames.conf'))
          .listen(_handleFileSystemEvent);

      log.d('BitNames config file watching enabled for ${confDir.path}');
    } catch (e) {
      log.e('Failed to setup BitNames config file watching: $e');
    }
  }

  void _handleFileSystemEvent(FileSystemEvent event) {
    log.d('BitNames config file changed: ${event.path}');

    _fileWatchDebouncer?.cancel();
    _fileWatchDebouncer = Timer(const Duration(milliseconds: 500), () {
      _reloadConfigFromFileSystem();
    });
  }

  void _reloadConfigFromFileSystem() async {
    try {
      log.i('Reloading BitNames config due to file system change');

      final confPath = _getConfigPath();
      final file = File(confPath);

      if (await file.exists()) {
        final content = await file.readAsString();
        final newConfig = BitnamesConfig.parse(content);

        if (newConfig != currentConfig) {
          currentConfig = newConfig;
          notifyListeners();
        }
      }
    } catch (e) {
      log.e('Failed to reload BitNames config from file system: $e');
    }
  }
}
